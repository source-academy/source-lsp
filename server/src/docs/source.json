[
  [
    {
      "label": "Infinity",
      "title": "Infinity:number",
      "description": "```source\nInfinity:number\n```\n\nThe name `Infinity` refers to the special number value `Infinity`. See [ECMAScript Specification, Section 4.3.23](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-value-properties-of-the-global-object-infinity)",
      "meta": "const"
    },
    {
      "label": "math_E",
      "title": "math_E:number",
      "description": "```source\nmath\\_E:number\n```\n\nThe Number value for e, Euler's number, which is approximately 2.718281828459045.",
      "meta": "const"
    },
    {
      "label": "math_LN2",
      "title": "math_LN2:number",
      "description": "```source\nmath\\_LN2:number\n```\n\nThe Number value for the natural logarithm of 2, which is approximately 0.6931471805599453.",
      "meta": "const"
    },
    {
      "label": "math_LN10",
      "title": "math_LN10:number",
      "description": "```source\nmath\\_LN10:number\n```\n\nThe Number value for the natural logarithm of 10, which is approximately 2.302585092994046.",
      "meta": "const"
    },
    {
      "label": "math_LOG2E",
      "title": "math_LOG2E:number",
      "description": "```source\nmath\\_LOG2E:number\n```\n\nThe Number value for the base-2 logarithm of eℝ, the base of the natural logarithms; this value is approximately 1.4426950408889634.\n\nNOTE: The value of math\\_LOG2E is approximately the reciprocal of the value of math\\_LN2.",
      "meta": "const"
    },
    {
      "label": "math_LOG10E",
      "title": "math_LOG10E:number",
      "description": "```source\nmath\\_LOG10E:number\n```\n\nThe Number value for the base-10 logarithm of e, the base of the natural logarithms; this value is approximately 0.4342944819032518.\n\nNOTE: The value of math\\_LOG10E is approximately the reciprocal of the value of math\\_LN10.",
      "meta": "const"
    },
    {
      "label": "math_PI",
      "title": "math_PI:number",
      "description": "```source\nmath\\_PI:number\n```\n\nThe Number value for π, the ratio of the circumference of a circle to its diameter, which is approximately 3.1415926535897932.",
      "meta": "const"
    },
    {
      "label": "math_SQRT1_2",
      "title": "math_SQRT1_2:number",
      "description": "```source\nmath\\_SQRT1\\_2:number\n```\n\nThe Number value for the square root of 0.5, which is approximately 0.7071067811865476.\n\nNOTE: The value of math\\_SQRT1\\_2 is approximately the reciprocal of the value of math\\_SQRT2.",
      "meta": "const"
    },
    {
      "label": "math_SQRT2",
      "title": "math_SQRT2:number",
      "description": "```source\nmath\\_SQRT2:number\n```\n\nThe Number value for the square root of 2, which is approximately 1.4142135623730951.",
      "meta": "const"
    },
    {
      "label": "NaN",
      "title": "NaN:number",
      "description": "```source\nNaN:number\n```\n\nThe name `NaN` refers to the special number value `NaN` (\"not a number\"). Note that `NaN` is a number, as specified by `is_number`. See [ECMAScript Specification, Section 4.3.24](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-value-properties-of-the-global-object-nan)",
      "meta": "const"
    },
    {
      "label": "undefined",
      "title": "undefined:undefined",
      "description": "```source\nundefined:undefined\n```\n\nThe name `undefined` refers to the special value `undefined`. See also [textbook explanation in section 4.1.1](https://sourceacademy.org/sicpjs/4.1.1#h5).",
      "meta": "const"
    },
    {
      "label": "arity",
      "title": "arity(f) → {number}",
      "description": "```source\narity(f) → {number}\n```\n\nReturns the number of parameters the given function `f` expects, excluding the rest parameter.",
      "meta": "func",
      "parameters": [
        "f"
      ]
    },
    {
      "label": "char_at",
      "title": "char_at(s, i) → {string}",
      "description": "```source\nchar\\_at(s, i) → {string}\n```\n\nTakes a string `s` as first argument and a nonnegative integer `i` as second argument. If `i` is less than the length of `s`, this function returns a one-character string that contains the character of `s` at position `i`, counting from 0. If `i` is larger than or equal to the length of `s`, this function returns `undefined`.",
      "meta": "func",
      "parameters": [
        "s",
        "i"
      ]
    },
    {
      "label": "display",
      "title": "display(v, s) → {value}",
      "description": "```source\ndisplay(v, s) → {value}\n```\n\nOptional second argument. If present, displays the given string `s`, followed by a space character, followed by the value `v` in the console. If second argument not present, just displays the value `v` in the console. The notation used for the display of values is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects.",
      "meta": "func",
      "parameters": [
        "v",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "error",
      "title": "error(v, s)",
      "description": "```source\nerror(v, s)\n```\n\nOptional second argument. If present, displays the given string `s`, followed by a space character, followed by the value `v` in the console with error flag. If second argument not present, just displays the value `v` in the console with error flag. The evaluation of any call of `error` aborts the running program immediately. The notation used for the display of values is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects.",
      "meta": "func",
      "parameters": [
        "v",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "get_time",
      "title": "get_time() → {number}",
      "description": "```source\nget\\_time() → {number}\n```\n\nReturns number of milliseconds elapsed since January 1, 1970 00:00:00 UTC. See also [textbook example](https://sourceacademy.org/sicpjs/1.2.6#ex-1.21).",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "is_boolean",
      "title": "is_boolean(v) → {boolean}",
      "description": "```source\nis\\_boolean(v) → {boolean}\n```\n\nchecks whether a given value is a boolean",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_function",
      "title": "is_function(v) → {boolean}",
      "description": "```source\nis\\_function(v) → {boolean}\n```\n\nchecks whether a given value is a function",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_number",
      "title": "is_number(v) → {boolean}",
      "description": "```source\nis\\_number(v) → {boolean}\n```\n\nchecks whether a given value is a number. See also [textbook example](https://sourceacademy.org/sicpjs/2.3.2).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_string",
      "title": "is_string(v) → {boolean}",
      "description": "```source\nis\\_string(v) → {boolean}\n```\n\nchecks whether a given value is a string. See also [textbook example](https://sourceacademy.org/sicpjs/2.3.2).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_undefined",
      "title": "is_undefined(v) → {boolean}",
      "description": "```source\nis\\_undefined(v) → {boolean}\n```\n\nchecks whether a given value is the special value `undefined`",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "math_abs",
      "title": "math_abs(x) → {number}",
      "description": "```source\nmath\\_abs(x) → {number}\n```\n\ncomputes the absolute value of x; the result has the same magnitude as `x` but has positive sign.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_acos",
      "title": "math_acos(x) → {number}",
      "description": "```source\nmath\\_acos(x) → {number}\n```\n\ncomputes the arc cosine of `x`. The result is expressed in radians and ranges from +0 to +π.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_acosh",
      "title": "math_acosh(x) → {number}",
      "description": "```source\nmath\\_acosh(x) → {number}\n```\n\ncomputes the inverse hyperbolic cosine of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_asin",
      "title": "math_asin(x) → {number}",
      "description": "```source\nmath\\_asin(x) → {number}\n```\n\ncomputes the arc sine of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_asinh",
      "title": "math_asinh(x) → {number}",
      "description": "```source\nmath\\_asinh(x) → {number}\n```\n\ncomputes the inverse hyperbolic sine of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_atan",
      "title": "math_atan(x) → {number}",
      "description": "```source\nmath\\_atan(x) → {number}\n```\n\ncomputes the arc tangent of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_atan2",
      "title": "math_atan2(y, x) → {number}",
      "description": "```source\nmath\\_atan2(y, x) → {number}\n```\n\ncomputes the arc tangent of the quotient `y` / `x` of the arguments `y` and `x`, where the signs of `y` and `x` are used to determine the quadrant of the result. Note that it is intentional and traditional for the two-argument arc tangent function that the argument named `y` be first and the argument named `x` be second. The result is expressed in radians and ranges from -π to +π.",
      "meta": "func",
      "parameters": [
        "y",
        "x"
      ]
    },
    {
      "label": "math_atanh",
      "title": "math_atanh(x) → {number}",
      "description": "```source\nmath\\_atanh(x) → {number}\n```\n\ncomputes the inverse hyperbolic tangent of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_cbrt",
      "title": "math_cbrt(x) → {number}",
      "description": "```source\nmath\\_cbrt(x) → {number}\n```\n\ncomputes the cube root of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_ceil",
      "title": "math_ceil(x) → {number}",
      "description": "```source\nmath\\_ceil(x) → {number}\n```\n\ncomputes the smallest (closest to -∞) Number value that is not less than `x` and is an integer. If `x` is already an integer, the result is `x`. The value of math\\_ceil(x) is the same as the value of -math\\_floor(-x).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_clz32",
      "title": "math_clz32(n) → {number}",
      "description": "```source\nmath\\_clz32(n) → {number}\n```\n\nWhen math\\_clz32 is called with one argument `x`, the following steps are taken: Let n be ToUint32(x). Let p be the number of leading zero bits in the 32-bit binary representation of n. Return p.\n\nNOTE:  \nIf n is 0, p will be 32. If the most significant bit of the 32-bit binary encoding of n is 1, p will be 0.",
      "meta": "func",
      "parameters": [
        "n"
      ]
    },
    {
      "label": "math_cos",
      "title": "math_cos(x) → {number}",
      "description": "```source\nmath\\_cos(x) → {number}\n```\n\nComputes the cosine of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_cosh",
      "title": "math_cosh(x) → {number}",
      "description": "```source\nmath\\_cosh(x) → {number}\n```\n\ncomputes the hyperbolic cosine of `x`.\n\nNOTE: The value of cosh(x) is the same as (exp(x) + exp(-x)) / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_exp",
      "title": "math_exp(x) → {number}",
      "description": "```source\nmath\\_exp(x) → {number}\n```\n\ncomputes the exponential function of `x` (e raised to the power of `x`, where e is the base of the natural logarithms).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_expm1",
      "title": "math_expm1(x) → {number}",
      "description": "```source\nmath\\_expm1(x) → {number}\n```\n\ncomputes subtracting 1 from the exponential function of `x` (e raised to the power of `x`, where e is the base of the natural logarithms). The result is computed in a way that is accurate even when the value of `x` is close to 0.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_floor",
      "title": "math_floor(x) → {number}",
      "description": "```source\nmath\\_floor(x) → {number}\n```\n\ncomputes the greatest (closest to +∞) Number value that is not greater than `x` and is an integer.  \nIf `x` is already an integer, the result is `x`.\n\nNOTE: The value of math\\_floor(x) is the same as the value of -math\\_ceil(-x).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_fround",
      "title": "math_fround(x) → {number}",
      "description": "```source\nmath\\_fround(x) → {number}\n```\n\nWhen math\\_fround is called with argument `x`, the following steps are taken:\n\n1.  If `x` is NaN, return NaN.\n2.  If `x` is one of +0, -0, +∞, -∞, return `x`.\n3.  Let x32 be the result of converting `x` to a value in IEEE 754-2008 binary32 format using roundTiesToEven mode.\n4.  Let x64 be the result of converting x32 to a value in IEEE 754-2008 binary64 format.\n5.  Return the ECMAScript Number value corresponding to x64.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_hypot",
      "title": "math_hypot() → {number}",
      "description": "```source\nmath\\_hypot() → {number}\n```\n\ncomputes the square root of the sum of squares of its arguments.  \nIf no arguments are passed, the result is +0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_imul",
      "title": "math_imul(x, x) → {number}",
      "description": "```source\nmath\\_imul(x, x) → {number}\n```\n\nWhen math\\_imul is called with arguments `x` and `y`, the following steps are taken:\n\n1.  Let a be ToUint32(x).\n2.  Let b be ToUint32(y).\n3.  Let product be (a × b) modulo 232.\n4.  If product ≥ 231, return product - 232; otherwise return product.",
      "meta": "func",
      "parameters": [
        "x",
        "x"
      ]
    },
    {
      "label": "math_log",
      "title": "math_log(x) → {number}",
      "description": "```source\nmath\\_log(x) → {number}\n```\n\nComputes the natural logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log1p",
      "title": "math_log1p(x) → {number}",
      "description": "```source\nmath\\_log1p(x) → {number}\n```\n\ncomputes the natural logarithm of 1 + `x`. The result is computed in a way that is accurate even when the value of `x` is close to zero.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log2",
      "title": "math_log2(x) → {number}",
      "description": "```source\nmath\\_log2(x) → {number}\n```\n\ncomputes the base 2 logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log10",
      "title": "math_log10(x) → {number}",
      "description": "```source\nmath\\_log10(x) → {number}\n```\n\ncomputes the base 10 logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_max",
      "title": "math_max() → {number}",
      "description": "```source\nmath\\_max() → {number}\n```\n\nGiven zero or more numbers, returns the largest of them.  \nIf no arguments are given, the result is -∞.  \nIf any value is NaN, the result is NaN. The comparison of values to determine the largest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_min",
      "title": "math_min() → {number}",
      "description": "```source\nmath\\_min() → {number}\n```\n\nGiven zero or more arguments, returns the smallest of them.  \nIf no arguments are given, the result is +∞.  \nIf any value is NaN, the result is NaN. The comparison of values to determine the smallest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_pow",
      "title": "math_pow(base, exponent) → {number}",
      "description": "```source\nmath\\_pow(base, exponent) → {number}\n```\n\nComputes the result of raising base to the power of exponent.",
      "meta": "func",
      "parameters": [
        "base",
        "exponent"
      ]
    },
    {
      "label": "math_random",
      "title": "math_random() → {number}",
      "description": "```source\nmath\\_random() → {number}\n```\n\nReturns a number value with positive sign, greater than or equal to 0 but less than 1, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. This function takes no arguments. Each math\\_random function created for distinct realms must produce a distinct sequence of values from successive calls.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_round",
      "title": "math_round(x) → {number}",
      "description": "```source\nmath\\_round(x) → {number}\n```\n\nReturns the number value that is closest to `x` and is an integer.  \nIf two integers are equally close to `x`, then the result is the Number value that is closer to +∞. If `x` is already an integer, the result is `x`. NOTE 1: math\\_round(3.5) returns 4, but math\\_round(-3.5) returns -3.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sign",
      "title": "math_sign(x) → {number}",
      "description": "```source\nmath\\_sign(x) → {number}\n```\n\nComputes the sign of `x`, indicating whether `x` is positive, negative, or zero.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sin",
      "title": "math_sin(x) → {number}",
      "description": "```source\nmath\\_sin(x) → {number}\n```\n\nComputes the sine of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sinh",
      "title": "math_sinh(x) → {number}",
      "description": "```source\nmath\\_sinh(x) → {number}\n```\n\nComputes the hyperbolic sine of `x`.\n\nNOTE: The value of sinh(x) is the same as (exp(x) - exp(-x)) / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sqrt",
      "title": "math_sqrt(x) → {number}",
      "description": "```source\nmath\\_sqrt(x) → {number}\n```\n\nComputes the square root of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_tan",
      "title": "math_tan(x) → {number}",
      "description": "```source\nmath\\_tan(x) → {number}\n```\n\nComputes the tangent of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_tanh",
      "title": "math_tanh(x) → {number}",
      "description": "```source\nmath\\_tanh(x) → {number}\n```\n\nComputes the hyperbolic tangent of `x`.\n\nNOTE: The value of `math_tanh(x)` is the same as `(exp(x) - exp(-x))/(exp(x) + exp(-x))`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_trunc",
      "title": "math_trunc(x) → {number}",
      "description": "```source\nmath\\_trunc(x) → {number}\n```\n\nComputes the integral part of the number `x`, removing any fractional digits.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "parse_int",
      "title": "parse_int(s, i) → {number}",
      "description": "```source\nparse\\_int(s, i) → {number}\n```\n\nInterprets a given string `s` as an integer, using the positive integer `i` as radix, and returns the respective value.  \nExamples: `parse_int(\"909\", 10)` returns the number `909`, and `parse_int(\"-1111\", 2)` returns the number `-15`.  \nSee [ECMAScript Specification, Section 18.2.5](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-parseint-string-radix) for details.",
      "meta": "func",
      "parameters": [
        "s",
        "i"
      ]
    },
    {
      "label": "prompt",
      "title": "prompt(s) → {string}",
      "description": "```source\nprompt(s) → {string}\n```\n\nPops up a window that displays the string `s`, provides an input line for the user to enter a text, a `Cancel` button and an `OK` button. The call of `prompt` suspends execution of the program until one of the two buttons is pressed. If the `OK` button is pressed, `prompt` returns the entered text as a string. If the `Cancel` button is pressed, `prompt` returns a non-string value.",
      "meta": "func",
      "parameters": [
        "s"
      ]
    },
    {
      "label": "stringify",
      "title": "stringify(v) → {string}",
      "description": "```source\nstringify(v) → {string}\n```\n\nreturns a string that represents the value `v`, using a notation that is is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects. See also [textbook example](https://sourceacademy.org/sicpjs/3.3.5).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    }
  ],
  [
    {
      "label": "Infinity",
      "title": "Infinity:number",
      "description": "```source\nInfinity:number\n```\n\nThe name `Infinity` refers to the special number value `Infinity`. See [ECMAScript Specification, Section 4.3.23](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-value-properties-of-the-global-object-infinity)",
      "meta": "const"
    },
    {
      "label": "math_E",
      "title": "math_E:number",
      "description": "```source\nmath\\_E:number\n```\n\nThe Number value for e, Euler's number, which is approximately 2.718281828459045.",
      "meta": "const"
    },
    {
      "label": "math_LN2",
      "title": "math_LN2:number",
      "description": "```source\nmath\\_LN2:number\n```\n\nThe Number value for the natural logarithm of 2, which is approximately 0.6931471805599453.",
      "meta": "const"
    },
    {
      "label": "math_LN10",
      "title": "math_LN10:number",
      "description": "```source\nmath\\_LN10:number\n```\n\nThe Number value for the natural logarithm of 10, which is approximately 2.302585092994046.",
      "meta": "const"
    },
    {
      "label": "math_LOG2E",
      "title": "math_LOG2E:number",
      "description": "```source\nmath\\_LOG2E:number\n```\n\nThe Number value for the base-2 logarithm of eℝ, the base of the natural logarithms; this value is approximately 1.4426950408889634.\n\nNOTE: The value of math\\_LOG2E is approximately the reciprocal of the value of math\\_LN2.",
      "meta": "const"
    },
    {
      "label": "math_LOG10E",
      "title": "math_LOG10E:number",
      "description": "```source\nmath\\_LOG10E:number\n```\n\nThe Number value for the base-10 logarithm of e, the base of the natural logarithms; this value is approximately 0.4342944819032518.\n\nNOTE: The value of math\\_LOG10E is approximately the reciprocal of the value of math\\_LN10.",
      "meta": "const"
    },
    {
      "label": "math_PI",
      "title": "math_PI:number",
      "description": "```source\nmath\\_PI:number\n```\n\nThe Number value for π, the ratio of the circumference of a circle to its diameter, which is approximately 3.1415926535897932.",
      "meta": "const"
    },
    {
      "label": "math_SQRT1_2",
      "title": "math_SQRT1_2:number",
      "description": "```source\nmath\\_SQRT1\\_2:number\n```\n\nThe Number value for the square root of 0.5, which is approximately 0.7071067811865476.\n\nNOTE: The value of math\\_SQRT1\\_2 is approximately the reciprocal of the value of math\\_SQRT2.",
      "meta": "const"
    },
    {
      "label": "math_SQRT2",
      "title": "math_SQRT2:number",
      "description": "```source\nmath\\_SQRT2:number\n```\n\nThe Number value for the square root of 2, which is approximately 1.4142135623730951.",
      "meta": "const"
    },
    {
      "label": "NaN",
      "title": "NaN:number",
      "description": "```source\nNaN:number\n```\n\nThe name `NaN` refers to the special number value `NaN` (\"not a number\"). Note that `NaN` is a number, as specified by `is_number`. See [ECMAScript Specification, Section 4.3.24](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-value-properties-of-the-global-object-nan)",
      "meta": "const"
    },
    {
      "label": "undefined",
      "title": "undefined:undefined",
      "description": "```source\nundefined:undefined\n```\n\nThe name `undefined` refers to the special value `undefined`. See also [textbook explanation in section 4.1.1](https://sourceacademy.org/sicpjs/4.1.1#h5).",
      "meta": "const"
    },
    {
      "label": "__access_export__",
      "title": "__access_export__(exports, lookup_name) → {value}",
      "description": "```source\n\\_\\_access\\_export\\_\\_(exports, lookup\\_name) → {value}\n```\n\nSearches for the specified name in the data structure of exported names. The data structure is a pair where the head element is the default export and the tail element is a list of pairs where each pair is a mapping from the exported name to the value being exported. If the lookup name is \"default\", the default export is returned instead of a named export. If the name does not exist, `undefined` is returned.",
      "meta": "func",
      "parameters": [
        "exports",
        "lookup_name"
      ]
    },
    {
      "label": "__access_named_export__",
      "title": "__access_named_export__(named_exports, lookup_name) → {value}",
      "description": "```source\n\\_\\_access\\_named\\_export\\_\\_(named\\_exports, lookup\\_name) → {value}\n```\n\nSearches for the specified name in the data structure of exported names. The data structure is a list of pairs where each pair is a mapping from the exported name to the value being exported. If the name does not exist, `undefined` is returned.",
      "meta": "func",
      "parameters": [
        "named_exports",
        "lookup_name"
      ]
    },
    {
      "label": "accumulate",
      "title": "accumulate(f, initial, xs) → {value}",
      "description": "```source\naccumulate(f, initial, xs) → {value}\n```\n\nApplies binary function `f` to the elements of `xs` from right-to-left order, first applying `f` to the last element and the value `initial`, resulting in `r`1, then to the second-last element and `r`1, resulting in `r`2, etc, and finally to the first element and `r`n-1, where `n` is the length of the list. Thus, `accumulate(f,zero,list(1,2,3))` results in `f(1, f(2, f(3, zero)))`. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(n)` (apart from `f`), where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "(x, y) => ",
        "initial",
        "xs"
      ]
    },
    {
      "label": "append",
      "title": "append(xs, ys) → {list}",
      "description": "```source\nappend(xs, ys) → {list}\n```\n\nReturns a list that results from appending the list `ys` to the list `xs`. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`. In the result, null at the end of the first argument list is replaced by the second argument, regardless what the second argument consists of.",
      "meta": "func",
      "parameters": [
        "xs",
        "ys"
      ]
    },
    {
      "label": "arity",
      "title": "arity(f) → {number}",
      "description": "```source\narity(f) → {number}\n```\n\nReturns the number of parameters the given function `f` expects, excluding the rest parameter.",
      "meta": "func",
      "parameters": [
        "f"
      ]
    },
    {
      "label": "build_list",
      "title": "build_list(f, n) → {list}",
      "description": "```source\nbuild\\_list(f, n) → {list}\n```\n\nMakes a list with `n` elements by applying the unary function `f` to the numbers 0 to `n - 1`, assumed to be a nonnegative integer. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(n)` (apart from `f`).",
      "meta": "func",
      "parameters": [
        "x => ",
        "n"
      ]
    },
    {
      "label": "char_at",
      "title": "char_at(s, i) → {string}",
      "description": "```source\nchar\\_at(s, i) → {string}\n```\n\nTakes a string `s` as first argument and a nonnegative integer `i` as second argument. If `i` is less than the length of `s`, this function returns a one-character string that contains the character of `s` at position `i`, counting from 0. If `i` is larger than or equal to the length of `s`, this function returns `undefined`.",
      "meta": "func",
      "parameters": [
        "s",
        "i"
      ]
    },
    {
      "label": "display",
      "title": "display(v, s) → {value}",
      "description": "```source\ndisplay(v, s) → {value}\n```\n\nOptional second argument. If present, displays the given string `s`, followed by a space character, followed by the value `v` in the console. If second argument not present, just displays the value `v` in the console. The notation used for the display of values is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects.",
      "meta": "func",
      "parameters": [
        "v",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "display_list",
      "title": "display_list(xs, s) → {value}",
      "description": "```source\ndisplay\\_list(xs, s) → {value}\n```\n\nOptional second argument. Similar to `display`, but formats well-formed lists nicely if detected; time, space: `Theta(n)`, where `n` is the total number of data structures such as pairs in `x`.",
      "meta": "func",
      "parameters": [
        "xs",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "draw_data",
      "title": "draw_data() → {value}",
      "description": "```source\ndraw\\_data() → {value}\n```\n\nvisualizes the arguments in a separate drawing area in the Source Academy using box-and-pointer diagrams; time, space: `Theta(n)`, where `n` is the total number of data structures such as pairs in the arguments.",
      "meta": "func",
      "parameters": [],
      "hasRestElement": true
    },
    {
      "label": "enum_list",
      "title": "enum_list(start, end) → {list}",
      "description": "```source\nenum\\_list(start, end) → {list}\n```\n\nReturns a list that enumerates numbers starting from `start` using a step size of 1, until the number exceeds (`>`) `end`. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is `end - start`.",
      "meta": "func",
      "parameters": [
        "start",
        "end"
      ]
    },
    {
      "label": "equal",
      "title": "equal(x, y) → {boolean}",
      "description": "```source\nequal(x, y) → {boolean}\n```\n\nReturns `true` if both have the same structure with respect to `pair`, and identical values at corresponding leave positions (places that are not themselves pairs), and `false` otherwise. For the \"identical\", the values need to have the same type, otherwise the result is `false`. If corresponding leaves are boolean values, these values need to be the same. If both are `undefined` or both are `null`, the result is `true`. Otherwise they are compared with `===` (using the definition of `===` in the respective Source language in use). Time, space: `Theta(n)`, where `n` is the total number of data structures such as pairs in `x` and `y`.",
      "meta": "func",
      "parameters": [
        "x",
        "y"
      ]
    },
    {
      "label": "error",
      "title": "error(v, s)",
      "description": "```source\nerror(v, s)\n```\n\nOptional second argument. If present, displays the given string `s`, followed by a space character, followed by the value `v` in the console with error flag. If second argument not present, just displays the value `v` in the console with error flag. The evaluation of any call of `error` aborts the running program immediately. The notation used for the display of values is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects.",
      "meta": "func",
      "parameters": [
        "v",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "filter",
      "title": "filter(pred, xs) → {list}",
      "description": "```source\nfilter(pred, xs) → {list}\n```\n\nReturns a list that contains only those elements for which the one-argument function `pred` returns `true`. Iterative process; time: `Theta(n)` (apart from `pred`), space: `Theta(n)` (apart from `pred`), where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "for_each",
      "title": "for_each(f, xs) → {boolean}",
      "description": "```source\nfor\\_each(f, xs) → {boolean}\n```\n\nApplies unary function `f` to every element of the list `xs`. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(1)` (apart from `f`), where `n` is the length of `xs`. `f` is applied element-by-element: `for_each(fun, list(1, 2))` results in the calls `fun(1)` and `fun(2)`.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "get_time",
      "title": "get_time() → {number}",
      "description": "```source\nget\\_time() → {number}\n```\n\nReturns number of milliseconds elapsed since January 1, 1970 00:00:00 UTC. See also [textbook example](https://sourceacademy.org/sicpjs/1.2.6#ex-1.21).",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "head",
      "title": "head(p) → {value}",
      "description": "```source\nhead(p) → {value}\n```\n\n\\*\\*primitive\\*\\*; returns head (first component) of given pair `p`; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "p"
      ]
    },
    {
      "label": "is_boolean",
      "title": "is_boolean(v) → {boolean}",
      "description": "```source\nis\\_boolean(v) → {boolean}\n```\n\nchecks whether a given value is a boolean",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_function",
      "title": "is_function(v) → {boolean}",
      "description": "```source\nis\\_function(v) → {boolean}\n```\n\nchecks whether a given value is a function",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_list",
      "title": "is_list(xs) → {xs}",
      "description": "```source\nis\\_list(xs) → {xs}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `xs` is a list as defined in the textbook, and `false` otherwise. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of the chain of `tail` operations that can be applied to `xs`. `is_list` recurses down the list and checks that it ends with the empty list null",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "is_null",
      "title": "is_null(x) → {boolean}",
      "description": "```source\nis\\_null(x) → {boolean}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `x` is the empty list `null`, and `false` otherwise; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "is_number",
      "title": "is_number(v) → {boolean}",
      "description": "```source\nis\\_number(v) → {boolean}\n```\n\nchecks whether a given value is a number. See also [textbook example](https://sourceacademy.org/sicpjs/2.3.2).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_pair",
      "title": "is_pair(x) → {boolean}",
      "description": "```source\nis\\_pair(x) → {boolean}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `x` is a pair and false otherwise; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "is_string",
      "title": "is_string(v) → {boolean}",
      "description": "```source\nis\\_string(v) → {boolean}\n```\n\nchecks whether a given value is a string. See also [textbook example](https://sourceacademy.org/sicpjs/2.3.2).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_undefined",
      "title": "is_undefined(v) → {boolean}",
      "description": "```source\nis\\_undefined(v) → {boolean}\n```\n\nchecks whether a given value is the special value `undefined`",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "length",
      "title": "length(xs) → {number}",
      "description": "```source\nlength(xs) → {number}\n```\n\nReturns the length of the list `xs`. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "list",
      "title": "list() → {list}",
      "description": "```source\nlist() → {list}\n```\n\n\\*\\*primitive\\*\\*; given `n` values, returns a list of length `n`. The elements of the list are the given values in the given order; time: `Theta(n)Theta(n)`.",
      "meta": "func",
      "parameters": [],
      "hasRestElement": true
    },
    {
      "label": "list_ref",
      "title": "list_ref(xs, n) → {value}",
      "description": "```source\nlist\\_ref(xs, n) → {value}\n```\n\nReturns the element of list `xs` at position `n`, where the first element has index 0. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "xs",
        "n"
      ]
    },
    {
      "label": "list_to_string",
      "title": "list_to_string(xs) → {string}",
      "description": "```source\nlist\\_to\\_string(xs) → {string}\n```\n\nReturns a string that represents list `xs` using the text-based box-and-pointer notation `[...]`. Iterative process; time: `Theta(n)` where `n` is the size of the list, space: `Theta(m)` where `m` is the length of the string. The process is iterative, but consumes space `O(m)` because of the result string.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "map",
      "title": "map(f, xs) → {list}",
      "description": "```source\nmap(f, xs) → {list}\n```\n\nReturns a list that results from list `xs` by element-wise application of unary function `f`. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(n)` (apart from `f`), where `n` is the length of `xs`. `f` is applied element-by-element: `map(f, list(1, 2))` results in `list(f(1), f(2))`.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "math_abs",
      "title": "math_abs(x) → {number}",
      "description": "```source\nmath\\_abs(x) → {number}\n```\n\ncomputes the absolute value of x; the result has the same magnitude as `x` but has positive sign.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_acos",
      "title": "math_acos(x) → {number}",
      "description": "```source\nmath\\_acos(x) → {number}\n```\n\ncomputes the arc cosine of `x`. The result is expressed in radians and ranges from +0 to +π.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_acosh",
      "title": "math_acosh(x) → {number}",
      "description": "```source\nmath\\_acosh(x) → {number}\n```\n\ncomputes the inverse hyperbolic cosine of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_asin",
      "title": "math_asin(x) → {number}",
      "description": "```source\nmath\\_asin(x) → {number}\n```\n\ncomputes the arc sine of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_asinh",
      "title": "math_asinh(x) → {number}",
      "description": "```source\nmath\\_asinh(x) → {number}\n```\n\ncomputes the inverse hyperbolic sine of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_atan",
      "title": "math_atan(x) → {number}",
      "description": "```source\nmath\\_atan(x) → {number}\n```\n\ncomputes the arc tangent of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_atan2",
      "title": "math_atan2(y, x) → {number}",
      "description": "```source\nmath\\_atan2(y, x) → {number}\n```\n\ncomputes the arc tangent of the quotient `y` / `x` of the arguments `y` and `x`, where the signs of `y` and `x` are used to determine the quadrant of the result. Note that it is intentional and traditional for the two-argument arc tangent function that the argument named `y` be first and the argument named `x` be second. The result is expressed in radians and ranges from -π to +π.",
      "meta": "func",
      "parameters": [
        "y",
        "x"
      ]
    },
    {
      "label": "math_atanh",
      "title": "math_atanh(x) → {number}",
      "description": "```source\nmath\\_atanh(x) → {number}\n```\n\ncomputes the inverse hyperbolic tangent of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_cbrt",
      "title": "math_cbrt(x) → {number}",
      "description": "```source\nmath\\_cbrt(x) → {number}\n```\n\ncomputes the cube root of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_ceil",
      "title": "math_ceil(x) → {number}",
      "description": "```source\nmath\\_ceil(x) → {number}\n```\n\ncomputes the smallest (closest to -∞) Number value that is not less than `x` and is an integer. If `x` is already an integer, the result is `x`. The value of math\\_ceil(x) is the same as the value of -math\\_floor(-x).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_clz32",
      "title": "math_clz32(n) → {number}",
      "description": "```source\nmath\\_clz32(n) → {number}\n```\n\nWhen math\\_clz32 is called with one argument `x`, the following steps are taken: Let n be ToUint32(x). Let p be the number of leading zero bits in the 32-bit binary representation of n. Return p.\n\nNOTE:  \nIf n is 0, p will be 32. If the most significant bit of the 32-bit binary encoding of n is 1, p will be 0.",
      "meta": "func",
      "parameters": [
        "n"
      ]
    },
    {
      "label": "math_cos",
      "title": "math_cos(x) → {number}",
      "description": "```source\nmath\\_cos(x) → {number}\n```\n\nComputes the cosine of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_cosh",
      "title": "math_cosh(x) → {number}",
      "description": "```source\nmath\\_cosh(x) → {number}\n```\n\ncomputes the hyperbolic cosine of `x`.\n\nNOTE: The value of cosh(x) is the same as (exp(x) + exp(-x)) / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_exp",
      "title": "math_exp(x) → {number}",
      "description": "```source\nmath\\_exp(x) → {number}\n```\n\ncomputes the exponential function of `x` (e raised to the power of `x`, where e is the base of the natural logarithms).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_expm1",
      "title": "math_expm1(x) → {number}",
      "description": "```source\nmath\\_expm1(x) → {number}\n```\n\ncomputes subtracting 1 from the exponential function of `x` (e raised to the power of `x`, where e is the base of the natural logarithms). The result is computed in a way that is accurate even when the value of `x` is close to 0.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_floor",
      "title": "math_floor(x) → {number}",
      "description": "```source\nmath\\_floor(x) → {number}\n```\n\ncomputes the greatest (closest to +∞) Number value that is not greater than `x` and is an integer.  \nIf `x` is already an integer, the result is `x`.\n\nNOTE: The value of math\\_floor(x) is the same as the value of -math\\_ceil(-x).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_fround",
      "title": "math_fround(x) → {number}",
      "description": "```source\nmath\\_fround(x) → {number}\n```\n\nWhen math\\_fround is called with argument `x`, the following steps are taken:\n\n1.  If `x` is NaN, return NaN.\n2.  If `x` is one of +0, -0, +∞, -∞, return `x`.\n3.  Let x32 be the result of converting `x` to a value in IEEE 754-2008 binary32 format using roundTiesToEven mode.\n4.  Let x64 be the result of converting x32 to a value in IEEE 754-2008 binary64 format.\n5.  Return the ECMAScript Number value corresponding to x64.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_hypot",
      "title": "math_hypot() → {number}",
      "description": "```source\nmath\\_hypot() → {number}\n```\n\ncomputes the square root of the sum of squares of its arguments.  \nIf no arguments are passed, the result is +0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_imul",
      "title": "math_imul(x, x) → {number}",
      "description": "```source\nmath\\_imul(x, x) → {number}\n```\n\nWhen math\\_imul is called with arguments `x` and `y`, the following steps are taken:\n\n1.  Let a be ToUint32(x).\n2.  Let b be ToUint32(y).\n3.  Let product be (a × b) modulo 232.\n4.  If product ≥ 231, return product - 232; otherwise return product.",
      "meta": "func",
      "parameters": [
        "x",
        "x"
      ]
    },
    {
      "label": "math_log",
      "title": "math_log(x) → {number}",
      "description": "```source\nmath\\_log(x) → {number}\n```\n\nComputes the natural logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log1p",
      "title": "math_log1p(x) → {number}",
      "description": "```source\nmath\\_log1p(x) → {number}\n```\n\ncomputes the natural logarithm of 1 + `x`. The result is computed in a way that is accurate even when the value of `x` is close to zero.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log2",
      "title": "math_log2(x) → {number}",
      "description": "```source\nmath\\_log2(x) → {number}\n```\n\ncomputes the base 2 logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log10",
      "title": "math_log10(x) → {number}",
      "description": "```source\nmath\\_log10(x) → {number}\n```\n\ncomputes the base 10 logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_max",
      "title": "math_max() → {number}",
      "description": "```source\nmath\\_max() → {number}\n```\n\nGiven zero or more numbers, returns the largest of them.  \nIf no arguments are given, the result is -∞.  \nIf any value is NaN, the result is NaN. The comparison of values to determine the largest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_min",
      "title": "math_min() → {number}",
      "description": "```source\nmath\\_min() → {number}\n```\n\nGiven zero or more arguments, returns the smallest of them.  \nIf no arguments are given, the result is +∞.  \nIf any value is NaN, the result is NaN. The comparison of values to determine the smallest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_pow",
      "title": "math_pow(base, exponent) → {number}",
      "description": "```source\nmath\\_pow(base, exponent) → {number}\n```\n\nComputes the result of raising base to the power of exponent.",
      "meta": "func",
      "parameters": [
        "base",
        "exponent"
      ]
    },
    {
      "label": "math_random",
      "title": "math_random() → {number}",
      "description": "```source\nmath\\_random() → {number}\n```\n\nReturns a number value with positive sign, greater than or equal to 0 but less than 1, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. This function takes no arguments. Each math\\_random function created for distinct realms must produce a distinct sequence of values from successive calls.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_round",
      "title": "math_round(x) → {number}",
      "description": "```source\nmath\\_round(x) → {number}\n```\n\nReturns the number value that is closest to `x` and is an integer.  \nIf two integers are equally close to `x`, then the result is the Number value that is closer to +∞. If `x` is already an integer, the result is `x`. NOTE 1: math\\_round(3.5) returns 4, but math\\_round(-3.5) returns -3.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sign",
      "title": "math_sign(x) → {number}",
      "description": "```source\nmath\\_sign(x) → {number}\n```\n\nComputes the sign of `x`, indicating whether `x` is positive, negative, or zero.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sin",
      "title": "math_sin(x) → {number}",
      "description": "```source\nmath\\_sin(x) → {number}\n```\n\nComputes the sine of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sinh",
      "title": "math_sinh(x) → {number}",
      "description": "```source\nmath\\_sinh(x) → {number}\n```\n\nComputes the hyperbolic sine of `x`.\n\nNOTE: The value of sinh(x) is the same as (exp(x) - exp(-x)) / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sqrt",
      "title": "math_sqrt(x) → {number}",
      "description": "```source\nmath\\_sqrt(x) → {number}\n```\n\nComputes the square root of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_tan",
      "title": "math_tan(x) → {number}",
      "description": "```source\nmath\\_tan(x) → {number}\n```\n\nComputes the tangent of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_tanh",
      "title": "math_tanh(x) → {number}",
      "description": "```source\nmath\\_tanh(x) → {number}\n```\n\nComputes the hyperbolic tangent of `x`.\n\nNOTE: The value of `math_tanh(x)` is the same as `(exp(x) - exp(-x))/(exp(x) + exp(-x))`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_trunc",
      "title": "math_trunc(x) → {number}",
      "description": "```source\nmath\\_trunc(x) → {number}\n```\n\nComputes the integral part of the number `x`, removing any fractional digits.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "member",
      "title": "member(v, xs) → {list}",
      "description": "```source\nmember(v, xs) → {list}\n```\n\nReturns first postfix sublist whose head is identical to `v` (using `===`); returns `null` if the element does not occur in the list. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "pair",
      "title": "pair(x, y) → {pair}",
      "description": "```source\npair(x, y) → {pair}\n```\n\n\\*\\*primitive\\*\\*; makes a pair whose head (first component) is `x` and whose tail (second component) is `y`; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "x",
        "y"
      ]
    },
    {
      "label": "parse_int",
      "title": "parse_int(s, i) → {number}",
      "description": "```source\nparse\\_int(s, i) → {number}\n```\n\nInterprets a given string `s` as an integer, using the positive integer `i` as radix, and returns the respective value.  \nExamples: `parse_int(\"909\", 10)` returns the number `909`, and `parse_int(\"-1111\", 2)` returns the number `-15`.  \nSee [ECMAScript Specification, Section 18.2.5](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-parseint-string-radix) for details.",
      "meta": "func",
      "parameters": [
        "s",
        "i"
      ]
    },
    {
      "label": "prompt",
      "title": "prompt(s) → {string}",
      "description": "```source\nprompt(s) → {string}\n```\n\nPops up a window that displays the string `s`, provides an input line for the user to enter a text, a `Cancel` button and an `OK` button. The call of `prompt` suspends execution of the program until one of the two buttons is pressed. If the `OK` button is pressed, `prompt` returns the entered text as a string. If the `Cancel` button is pressed, `prompt` returns a non-string value.",
      "meta": "func",
      "parameters": [
        "s"
      ]
    },
    {
      "label": "remove",
      "title": "remove(v, xs) → {list}",
      "description": "```source\nremove(v, xs) → {list}\n```\n\nReturns a list that results from `xs` by removing the first item from `xs` that is identical (`===`) to `v`. Returns the original list if there is no occurrence. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "remove_all",
      "title": "remove_all(v, xs) → {list}",
      "description": "```source\nremove\\_all(v, xs) → {list}\n```\n\nReturns a list that results from `xs` by removing all items from `xs` that are identical (`===`) to `v`. Returns the original list if there is no occurrence. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "reverse",
      "title": "reverse(xs) → {list}",
      "description": "```source\nreverse(xs) → {list}\n```\n\nReturns list `xs` in reverse order. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`. The process is iterative, but consumes space `Theta(n)` because of the result list.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "stringify",
      "title": "stringify(v) → {string}",
      "description": "```source\nstringify(v) → {string}\n```\n\nreturns a string that represents the value `v`, using a notation that is is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects. See also [textbook example](https://sourceacademy.org/sicpjs/3.3.5).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "tail",
      "title": "tail(p) → {value}",
      "description": "```source\ntail(p) → {value}\n```\n\n\\*\\*primitive\\*\\*; returns tail (second component of given pair `p`; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "p"
      ]
    }
  ],
  [
    {
      "label": "Infinity",
      "title": "Infinity:number",
      "description": "```source\nInfinity:number\n```\n\nThe name `Infinity` refers to the special number value `Infinity`. See [ECMAScript Specification, Section 4.3.23](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-value-properties-of-the-global-object-infinity)",
      "meta": "const"
    },
    {
      "label": "math_E",
      "title": "math_E:number",
      "description": "```source\nmath\\_E:number\n```\n\nThe Number value for e, Euler's number, which is approximately 2.718281828459045.",
      "meta": "const"
    },
    {
      "label": "math_LN2",
      "title": "math_LN2:number",
      "description": "```source\nmath\\_LN2:number\n```\n\nThe Number value for the natural logarithm of 2, which is approximately 0.6931471805599453.",
      "meta": "const"
    },
    {
      "label": "math_LN10",
      "title": "math_LN10:number",
      "description": "```source\nmath\\_LN10:number\n```\n\nThe Number value for the natural logarithm of 10, which is approximately 2.302585092994046.",
      "meta": "const"
    },
    {
      "label": "math_LOG2E",
      "title": "math_LOG2E:number",
      "description": "```source\nmath\\_LOG2E:number\n```\n\nThe Number value for the base-2 logarithm of eℝ, the base of the natural logarithms; this value is approximately 1.4426950408889634.\n\nNOTE: The value of math\\_LOG2E is approximately the reciprocal of the value of math\\_LN2.",
      "meta": "const"
    },
    {
      "label": "math_LOG10E",
      "title": "math_LOG10E:number",
      "description": "```source\nmath\\_LOG10E:number\n```\n\nThe Number value for the base-10 logarithm of e, the base of the natural logarithms; this value is approximately 0.4342944819032518.\n\nNOTE: The value of math\\_LOG10E is approximately the reciprocal of the value of math\\_LN10.",
      "meta": "const"
    },
    {
      "label": "math_PI",
      "title": "math_PI:number",
      "description": "```source\nmath\\_PI:number\n```\n\nThe Number value for π, the ratio of the circumference of a circle to its diameter, which is approximately 3.1415926535897932.",
      "meta": "const"
    },
    {
      "label": "math_SQRT1_2",
      "title": "math_SQRT1_2:number",
      "description": "```source\nmath\\_SQRT1\\_2:number\n```\n\nThe Number value for the square root of 0.5, which is approximately 0.7071067811865476.\n\nNOTE: The value of math\\_SQRT1\\_2 is approximately the reciprocal of the value of math\\_SQRT2.",
      "meta": "const"
    },
    {
      "label": "math_SQRT2",
      "title": "math_SQRT2:number",
      "description": "```source\nmath\\_SQRT2:number\n```\n\nThe Number value for the square root of 2, which is approximately 1.4142135623730951.",
      "meta": "const"
    },
    {
      "label": "NaN",
      "title": "NaN:number",
      "description": "```source\nNaN:number\n```\n\nThe name `NaN` refers to the special number value `NaN` (\"not a number\"). Note that `NaN` is a number, as specified by `is_number`. See [ECMAScript Specification, Section 4.3.24](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-value-properties-of-the-global-object-nan)",
      "meta": "const"
    },
    {
      "label": "undefined",
      "title": "undefined:undefined",
      "description": "```source\nundefined:undefined\n```\n\nThe name `undefined` refers to the special value `undefined`. See also [textbook explanation in section 4.1.1](https://sourceacademy.org/sicpjs/4.1.1#h5).",
      "meta": "const"
    },
    {
      "label": "__access_export__",
      "title": "__access_export__(exports, lookup_name) → {value}",
      "description": "```source\n\\_\\_access\\_export\\_\\_(exports, lookup\\_name) → {value}\n```\n\nSearches for the specified name in the data structure of exported names. The data structure is a pair where the head element is the default export and the tail element is a list of pairs where each pair is a mapping from the exported name to the value being exported. If the lookup name is \"default\", the default export is returned instead of a named export. If the name does not exist, `undefined` is returned.",
      "meta": "func",
      "parameters": [
        "exports",
        "lookup_name"
      ]
    },
    {
      "label": "__access_named_export__",
      "title": "__access_named_export__(named_exports, lookup_name) → {value}",
      "description": "```source\n\\_\\_access\\_named\\_export\\_\\_(named\\_exports, lookup\\_name) → {value}\n```\n\nSearches for the specified name in the data structure of exported names. The data structure is a list of pairs where each pair is a mapping from the exported name to the value being exported. If the name does not exist, `undefined` is returned.",
      "meta": "func",
      "parameters": [
        "named_exports",
        "lookup_name"
      ]
    },
    {
      "label": "accumulate",
      "title": "accumulate(f, initial, xs) → {value}",
      "description": "```source\naccumulate(f, initial, xs) → {value}\n```\n\nApplies binary function `f` to the elements of `xs` from right-to-left order, first applying `f` to the last element and the value `initial`, resulting in `r`1, then to the second-last element and `r`1, resulting in `r`2, etc, and finally to the first element and `r`n-1, where `n` is the length of the list. Thus, `accumulate(f,zero,list(1,2,3))` results in `f(1, f(2, f(3, zero)))`. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(n)` (apart from `f`), where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "(x, y) => ",
        "initial",
        "xs"
      ]
    },
    {
      "label": "append",
      "title": "append(xs, ys) → {list}",
      "description": "```source\nappend(xs, ys) → {list}\n```\n\nReturns a list that results from appending the list `ys` to the list `xs`. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`. In the result, null at the end of the first argument list is replaced by the second argument, regardless what the second argument consists of.",
      "meta": "func",
      "parameters": [
        "xs",
        "ys"
      ]
    },
    {
      "label": "arity",
      "title": "arity(f) → {number}",
      "description": "```source\narity(f) → {number}\n```\n\nReturns the number of parameters the given function `f` expects, excluding the rest parameter.",
      "meta": "func",
      "parameters": [
        "f"
      ]
    },
    {
      "label": "array_length",
      "title": "array_length(x) → {number}",
      "description": "```source\narray\\_length(x) → {number}\n```\n\n\\*\\*primitive\\*\\*; returns the current length of array `x`, which is 1 plus the highest index that has been used so far in an array assignment on `x`. Here literal array expressions are counted too: The array `[10, 20, 30]` has a length of 3. Time: `Θ(1)`, space: `Θ(1)`",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "build_list",
      "title": "build_list(f, n) → {list}",
      "description": "```source\nbuild\\_list(f, n) → {list}\n```\n\nMakes a list with `n` elements by applying the unary function `f` to the numbers 0 to `n - 1`, assumed to be a nonnegative integer. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(n)` (apart from `f`).",
      "meta": "func",
      "parameters": [
        "x => ",
        "n"
      ]
    },
    {
      "label": "build_stream",
      "title": "build_stream(f, n) → {stream}",
      "description": "```source\nbuild\\_stream(f, n) → {stream}\n```\n\nMakes a stream with `n` elements by applying the unary function `f` to the numbers 0 to `n - 1`, assumed to be a nonnegative integer. Lazy? Yes: The result stream forces the application of `f` for the next element",
      "meta": "func",
      "parameters": [
        "x => ",
        "n"
      ]
    },
    {
      "label": "char_at",
      "title": "char_at(s, i) → {string}",
      "description": "```source\nchar\\_at(s, i) → {string}\n```\n\nTakes a string `s` as first argument and a nonnegative integer `i` as second argument. If `i` is less than the length of `s`, this function returns a one-character string that contains the character of `s` at position `i`, counting from 0. If `i` is larger than or equal to the length of `s`, this function returns `undefined`.",
      "meta": "func",
      "parameters": [
        "s",
        "i"
      ]
    },
    {
      "label": "display",
      "title": "display(v, s) → {value}",
      "description": "```source\ndisplay(v, s) → {value}\n```\n\nOptional second argument. If present, displays the given string `s`, followed by a space character, followed by the value `v` in the console. If second argument not present, just displays the value `v` in the console. The notation used for the display of values is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects.",
      "meta": "func",
      "parameters": [
        "v",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "display_list",
      "title": "display_list(xs, s) → {value}",
      "description": "```source\ndisplay\\_list(xs, s) → {value}\n```\n\nOptional second argument. Similar to `display`, but formats well-formed lists nicely if detected; time, space: `Theta(n)`, where `n` is the total number of data structures such as pairs in `x`.",
      "meta": "func",
      "parameters": [
        "xs",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "draw_data",
      "title": "draw_data() → {value}",
      "description": "```source\ndraw\\_data() → {value}\n```\n\nvisualizes the arguments in a separate drawing area in the Source Academy using box-and-pointer diagrams; time, space: `Theta(n)`, where `n` is the total number of data structures such as pairs in the arguments.",
      "meta": "func",
      "parameters": [],
      "hasRestElement": true
    },
    {
      "label": "enum_list",
      "title": "enum_list(start, end) → {list}",
      "description": "```source\nenum\\_list(start, end) → {list}\n```\n\nReturns a list that enumerates numbers starting from `start` using a step size of 1, until the number exceeds (`>`) `end`. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is `end - start`.",
      "meta": "func",
      "parameters": [
        "start",
        "end"
      ]
    },
    {
      "label": "enum_stream",
      "title": "enum_stream(start, end) → {stream}",
      "description": "```source\nenum\\_stream(start, end) → {stream}\n```\n\nReturns a stream that enumerates numbers starting from `start` using a step size of 1, until the number exceeds (`>`) `end`. Lazy? Yes: The result stream forces the construction of each next element",
      "meta": "func",
      "parameters": [
        "start",
        "end"
      ]
    },
    {
      "label": "equal",
      "title": "equal(x, y) → {boolean}",
      "description": "```source\nequal(x, y) → {boolean}\n```\n\nReturns `true` if both have the same structure with respect to `pair`, and identical values at corresponding leave positions (places that are not themselves pairs), and `false` otherwise. For the \"identical\", the values need to have the same type, otherwise the result is `false`. If corresponding leaves are boolean values, these values need to be the same. If both are `undefined` or both are `null`, the result is `true`. Otherwise they are compared with `===` (using the definition of `===` in the respective Source language in use). Time, space: `Theta(n)`, where `n` is the total number of data structures such as pairs in `x` and `y`.",
      "meta": "func",
      "parameters": [
        "x",
        "y"
      ]
    },
    {
      "label": "error",
      "title": "error(v, s)",
      "description": "```source\nerror(v, s)\n```\n\nOptional second argument. If present, displays the given string `s`, followed by a space character, followed by the value `v` in the console with error flag. If second argument not present, just displays the value `v` in the console with error flag. The evaluation of any call of `error` aborts the running program immediately. The notation used for the display of values is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects.",
      "meta": "func",
      "parameters": [
        "v",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "eval_stream",
      "title": "eval_stream(s, n) → {list}",
      "description": "```source\neval\\_stream(s, n) → {list}\n```\n\nConstructs the list of the first `n` elements of a given stream `s` Lazy? Sort-of: `eval_stream` only forces the computation of the first `n` elements, and leaves the rest of the stream untouched.",
      "meta": "func",
      "parameters": [
        "s",
        "n"
      ]
    },
    {
      "label": "filter",
      "title": "filter(pred, xs) → {list}",
      "description": "```source\nfilter(pred, xs) → {list}\n```\n\nReturns a list that contains only those elements for which the one-argument function `pred` returns `true`. Iterative process; time: `Theta(n)` (apart from `pred`), space: `Theta(n)` (apart from `pred`), where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "for_each",
      "title": "for_each(f, xs) → {boolean}",
      "description": "```source\nfor\\_each(f, xs) → {boolean}\n```\n\nApplies unary function `f` to every element of the list `xs`. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(1)` (apart from `f`), where `n` is the length of `xs`. `f` is applied element-by-element: `for_each(fun, list(1, 2))` results in the calls `fun(1)` and `fun(2)`.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "get_time",
      "title": "get_time() → {number}",
      "description": "```source\nget\\_time() → {number}\n```\n\nReturns number of milliseconds elapsed since January 1, 1970 00:00:00 UTC. See also [textbook example](https://sourceacademy.org/sicpjs/1.2.6#ex-1.21).",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "head",
      "title": "head(p) → {value}",
      "description": "```source\nhead(p) → {value}\n```\n\n\\*\\*primitive\\*\\*; returns head (first component) of given pair `p`; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "p"
      ]
    },
    {
      "label": "integers_from",
      "title": "integers_from(start) → {stream}",
      "description": "```source\nintegers\\_from(start) → {stream}\n```\n\nReturns infinite stream if integers starting at given number `n` using a step size of 1. Lazy? Yes: The result stream forces the construction of each next element",
      "meta": "func",
      "parameters": [
        "start"
      ]
    },
    {
      "label": "is_array",
      "title": "is_array(x) → {boolean}",
      "description": "```source\nis\\_array(x) → {boolean}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `x` is an array, and `false` if it is not. Time: `Θ(1)`, space: `Θ(1)`",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "is_boolean",
      "title": "is_boolean(v) → {boolean}",
      "description": "```source\nis\\_boolean(v) → {boolean}\n```\n\nchecks whether a given value is a boolean",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_function",
      "title": "is_function(v) → {boolean}",
      "description": "```source\nis\\_function(v) → {boolean}\n```\n\nchecks whether a given value is a function",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_list",
      "title": "is_list(xs) → {xs}",
      "description": "```source\nis\\_list(xs) → {xs}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `xs` is a list as defined in the textbook, and `false` otherwise. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of the chain of `tail` operations that can be applied to `xs`. `is_list` recurses down the list and checks that it ends with the empty list null",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "is_null",
      "title": "is_null(x) → {boolean}",
      "description": "```source\nis\\_null(x) → {boolean}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `x` is the empty list `null`, and `false` otherwise; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "is_number",
      "title": "is_number(v) → {boolean}",
      "description": "```source\nis\\_number(v) → {boolean}\n```\n\nchecks whether a given value is a number. See also [textbook example](https://sourceacademy.org/sicpjs/2.3.2).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_pair",
      "title": "is_pair(x) → {boolean}",
      "description": "```source\nis\\_pair(x) → {boolean}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `x` is a pair and false otherwise; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "is_stream",
      "title": "is_stream(xs) → {boolean}",
      "description": "```source\nis\\_stream(xs) → {boolean}\n```\n\nReturns `true` if `xs` is a stream as defined in the textbook, and `false` otherwise. Iterative process. Recurses down the stream and checks that it ends with the empty stream null. Laziness: No: `is_stream` needs to force the given stream.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "is_string",
      "title": "is_string(v) → {boolean}",
      "description": "```source\nis\\_string(v) → {boolean}\n```\n\nchecks whether a given value is a string. See also [textbook example](https://sourceacademy.org/sicpjs/2.3.2).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_undefined",
      "title": "is_undefined(v) → {boolean}",
      "description": "```source\nis\\_undefined(v) → {boolean}\n```\n\nchecks whether a given value is the special value `undefined`",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "length",
      "title": "length(xs) → {number}",
      "description": "```source\nlength(xs) → {number}\n```\n\nReturns the length of the list `xs`. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "list",
      "title": "list() → {list}",
      "description": "```source\nlist() → {list}\n```\n\n\\*\\*primitive\\*\\*; given `n` values, returns a list of length `n`. The elements of the list are the given values in the given order; time: `Theta(n)Theta(n)`.",
      "meta": "func",
      "parameters": [],
      "hasRestElement": true
    },
    {
      "label": "list_ref",
      "title": "list_ref(xs, n) → {value}",
      "description": "```source\nlist\\_ref(xs, n) → {value}\n```\n\nReturns the element of list `xs` at position `n`, where the first element has index 0. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "xs",
        "n"
      ]
    },
    {
      "label": "list_to_stream",
      "title": "list_to_stream(xs) → {stream}",
      "description": "```source\nlist\\_to\\_stream(xs) → {stream}\n```\n\nGiven list `xs`, returns a stream of same length with the same elements as `xs` in the same order. Laziness: Yes: `list_to_stream` goes down the list only when forced.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "list_to_string",
      "title": "list_to_string(xs) → {string}",
      "description": "```source\nlist\\_to\\_string(xs) → {string}\n```\n\nReturns a string that represents list `xs` using the text-based box-and-pointer notation `[...]`. Iterative process; time: `Theta(n)` where `n` is the size of the list, space: `Theta(m)` where `m` is the length of the string. The process is iterative, but consumes space `O(m)` because of the result string.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "map",
      "title": "map(f, xs) → {list}",
      "description": "```source\nmap(f, xs) → {list}\n```\n\nReturns a list that results from list `xs` by element-wise application of unary function `f`. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(n)` (apart from `f`), where `n` is the length of `xs`. `f` is applied element-by-element: `map(f, list(1, 2))` results in `list(f(1), f(2))`.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "math_abs",
      "title": "math_abs(x) → {number}",
      "description": "```source\nmath\\_abs(x) → {number}\n```\n\ncomputes the absolute value of x; the result has the same magnitude as `x` but has positive sign.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_acos",
      "title": "math_acos(x) → {number}",
      "description": "```source\nmath\\_acos(x) → {number}\n```\n\ncomputes the arc cosine of `x`. The result is expressed in radians and ranges from +0 to +π.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_acosh",
      "title": "math_acosh(x) → {number}",
      "description": "```source\nmath\\_acosh(x) → {number}\n```\n\ncomputes the inverse hyperbolic cosine of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_asin",
      "title": "math_asin(x) → {number}",
      "description": "```source\nmath\\_asin(x) → {number}\n```\n\ncomputes the arc sine of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_asinh",
      "title": "math_asinh(x) → {number}",
      "description": "```source\nmath\\_asinh(x) → {number}\n```\n\ncomputes the inverse hyperbolic sine of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_atan",
      "title": "math_atan(x) → {number}",
      "description": "```source\nmath\\_atan(x) → {number}\n```\n\ncomputes the arc tangent of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_atan2",
      "title": "math_atan2(y, x) → {number}",
      "description": "```source\nmath\\_atan2(y, x) → {number}\n```\n\ncomputes the arc tangent of the quotient `y` / `x` of the arguments `y` and `x`, where the signs of `y` and `x` are used to determine the quadrant of the result. Note that it is intentional and traditional for the two-argument arc tangent function that the argument named `y` be first and the argument named `x` be second. The result is expressed in radians and ranges from -π to +π.",
      "meta": "func",
      "parameters": [
        "y",
        "x"
      ]
    },
    {
      "label": "math_atanh",
      "title": "math_atanh(x) → {number}",
      "description": "```source\nmath\\_atanh(x) → {number}\n```\n\ncomputes the inverse hyperbolic tangent of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_cbrt",
      "title": "math_cbrt(x) → {number}",
      "description": "```source\nmath\\_cbrt(x) → {number}\n```\n\ncomputes the cube root of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_ceil",
      "title": "math_ceil(x) → {number}",
      "description": "```source\nmath\\_ceil(x) → {number}\n```\n\ncomputes the smallest (closest to -∞) Number value that is not less than `x` and is an integer. If `x` is already an integer, the result is `x`. The value of math\\_ceil(x) is the same as the value of -math\\_floor(-x).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_clz32",
      "title": "math_clz32(n) → {number}",
      "description": "```source\nmath\\_clz32(n) → {number}\n```\n\nWhen math\\_clz32 is called with one argument `x`, the following steps are taken: Let n be ToUint32(x). Let p be the number of leading zero bits in the 32-bit binary representation of n. Return p.\n\nNOTE:  \nIf n is 0, p will be 32. If the most significant bit of the 32-bit binary encoding of n is 1, p will be 0.",
      "meta": "func",
      "parameters": [
        "n"
      ]
    },
    {
      "label": "math_cos",
      "title": "math_cos(x) → {number}",
      "description": "```source\nmath\\_cos(x) → {number}\n```\n\nComputes the cosine of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_cosh",
      "title": "math_cosh(x) → {number}",
      "description": "```source\nmath\\_cosh(x) → {number}\n```\n\ncomputes the hyperbolic cosine of `x`.\n\nNOTE: The value of cosh(x) is the same as (exp(x) + exp(-x)) / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_exp",
      "title": "math_exp(x) → {number}",
      "description": "```source\nmath\\_exp(x) → {number}\n```\n\ncomputes the exponential function of `x` (e raised to the power of `x`, where e is the base of the natural logarithms).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_expm1",
      "title": "math_expm1(x) → {number}",
      "description": "```source\nmath\\_expm1(x) → {number}\n```\n\ncomputes subtracting 1 from the exponential function of `x` (e raised to the power of `x`, where e is the base of the natural logarithms). The result is computed in a way that is accurate even when the value of `x` is close to 0.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_floor",
      "title": "math_floor(x) → {number}",
      "description": "```source\nmath\\_floor(x) → {number}\n```\n\ncomputes the greatest (closest to +∞) Number value that is not greater than `x` and is an integer.  \nIf `x` is already an integer, the result is `x`.\n\nNOTE: The value of math\\_floor(x) is the same as the value of -math\\_ceil(-x).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_fround",
      "title": "math_fround(x) → {number}",
      "description": "```source\nmath\\_fround(x) → {number}\n```\n\nWhen math\\_fround is called with argument `x`, the following steps are taken:\n\n1.  If `x` is NaN, return NaN.\n2.  If `x` is one of +0, -0, +∞, -∞, return `x`.\n3.  Let x32 be the result of converting `x` to a value in IEEE 754-2008 binary32 format using roundTiesToEven mode.\n4.  Let x64 be the result of converting x32 to a value in IEEE 754-2008 binary64 format.\n5.  Return the ECMAScript Number value corresponding to x64.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_hypot",
      "title": "math_hypot() → {number}",
      "description": "```source\nmath\\_hypot() → {number}\n```\n\ncomputes the square root of the sum of squares of its arguments.  \nIf no arguments are passed, the result is +0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_imul",
      "title": "math_imul(x, x) → {number}",
      "description": "```source\nmath\\_imul(x, x) → {number}\n```\n\nWhen math\\_imul is called with arguments `x` and `y`, the following steps are taken:\n\n1.  Let a be ToUint32(x).\n2.  Let b be ToUint32(y).\n3.  Let product be (a × b) modulo 232.\n4.  If product ≥ 231, return product - 232; otherwise return product.",
      "meta": "func",
      "parameters": [
        "x",
        "x"
      ]
    },
    {
      "label": "math_log",
      "title": "math_log(x) → {number}",
      "description": "```source\nmath\\_log(x) → {number}\n```\n\nComputes the natural logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log1p",
      "title": "math_log1p(x) → {number}",
      "description": "```source\nmath\\_log1p(x) → {number}\n```\n\ncomputes the natural logarithm of 1 + `x`. The result is computed in a way that is accurate even when the value of `x` is close to zero.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log2",
      "title": "math_log2(x) → {number}",
      "description": "```source\nmath\\_log2(x) → {number}\n```\n\ncomputes the base 2 logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log10",
      "title": "math_log10(x) → {number}",
      "description": "```source\nmath\\_log10(x) → {number}\n```\n\ncomputes the base 10 logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_max",
      "title": "math_max() → {number}",
      "description": "```source\nmath\\_max() → {number}\n```\n\nGiven zero or more numbers, returns the largest of them.  \nIf no arguments are given, the result is -∞.  \nIf any value is NaN, the result is NaN. The comparison of values to determine the largest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_min",
      "title": "math_min() → {number}",
      "description": "```source\nmath\\_min() → {number}\n```\n\nGiven zero or more arguments, returns the smallest of them.  \nIf no arguments are given, the result is +∞.  \nIf any value is NaN, the result is NaN. The comparison of values to determine the smallest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_pow",
      "title": "math_pow(base, exponent) → {number}",
      "description": "```source\nmath\\_pow(base, exponent) → {number}\n```\n\nComputes the result of raising base to the power of exponent.",
      "meta": "func",
      "parameters": [
        "base",
        "exponent"
      ]
    },
    {
      "label": "math_random",
      "title": "math_random() → {number}",
      "description": "```source\nmath\\_random() → {number}\n```\n\nReturns a number value with positive sign, greater than or equal to 0 but less than 1, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. This function takes no arguments. Each math\\_random function created for distinct realms must produce a distinct sequence of values from successive calls.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_round",
      "title": "math_round(x) → {number}",
      "description": "```source\nmath\\_round(x) → {number}\n```\n\nReturns the number value that is closest to `x` and is an integer.  \nIf two integers are equally close to `x`, then the result is the Number value that is closer to +∞. If `x` is already an integer, the result is `x`. NOTE 1: math\\_round(3.5) returns 4, but math\\_round(-3.5) returns -3.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sign",
      "title": "math_sign(x) → {number}",
      "description": "```source\nmath\\_sign(x) → {number}\n```\n\nComputes the sign of `x`, indicating whether `x` is positive, negative, or zero.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sin",
      "title": "math_sin(x) → {number}",
      "description": "```source\nmath\\_sin(x) → {number}\n```\n\nComputes the sine of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sinh",
      "title": "math_sinh(x) → {number}",
      "description": "```source\nmath\\_sinh(x) → {number}\n```\n\nComputes the hyperbolic sine of `x`.\n\nNOTE: The value of sinh(x) is the same as (exp(x) - exp(-x)) / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sqrt",
      "title": "math_sqrt(x) → {number}",
      "description": "```source\nmath\\_sqrt(x) → {number}\n```\n\nComputes the square root of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_tan",
      "title": "math_tan(x) → {number}",
      "description": "```source\nmath\\_tan(x) → {number}\n```\n\nComputes the tangent of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_tanh",
      "title": "math_tanh(x) → {number}",
      "description": "```source\nmath\\_tanh(x) → {number}\n```\n\nComputes the hyperbolic tangent of `x`.\n\nNOTE: The value of `math_tanh(x)` is the same as `(exp(x) - exp(-x))/(exp(x) + exp(-x))`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_trunc",
      "title": "math_trunc(x) → {number}",
      "description": "```source\nmath\\_trunc(x) → {number}\n```\n\nComputes the integral part of the number `x`, removing any fractional digits.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "member",
      "title": "member(v, xs) → {list}",
      "description": "```source\nmember(v, xs) → {list}\n```\n\nReturns first postfix sublist whose head is identical to `v` (using `===`); returns `null` if the element does not occur in the list. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "pair",
      "title": "pair(x, y) → {pair}",
      "description": "```source\npair(x, y) → {pair}\n```\n\n\\*\\*primitive\\*\\*; makes a pair whose head (first component) is `x` and whose tail (second component) is `y`; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "x",
        "y"
      ]
    },
    {
      "label": "parse_int",
      "title": "parse_int(s, i) → {number}",
      "description": "```source\nparse\\_int(s, i) → {number}\n```\n\nInterprets a given string `s` as an integer, using the positive integer `i` as radix, and returns the respective value.  \nExamples: `parse_int(\"909\", 10)` returns the number `909`, and `parse_int(\"-1111\", 2)` returns the number `-15`.  \nSee [ECMAScript Specification, Section 18.2.5](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-parseint-string-radix) for details.",
      "meta": "func",
      "parameters": [
        "s",
        "i"
      ]
    },
    {
      "label": "prompt",
      "title": "prompt(s) → {string}",
      "description": "```source\nprompt(s) → {string}\n```\n\nPops up a window that displays the string `s`, provides an input line for the user to enter a text, a `Cancel` button and an `OK` button. The call of `prompt` suspends execution of the program until one of the two buttons is pressed. If the `OK` button is pressed, `prompt` returns the entered text as a string. If the `Cancel` button is pressed, `prompt` returns a non-string value.",
      "meta": "func",
      "parameters": [
        "s"
      ]
    },
    {
      "label": "remove",
      "title": "remove(v, xs) → {list}",
      "description": "```source\nremove(v, xs) → {list}\n```\n\nReturns a list that results from `xs` by removing the first item from `xs` that is identical (`===`) to `v`. Returns the original list if there is no occurrence. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "remove_all",
      "title": "remove_all(v, xs) → {list}",
      "description": "```source\nremove\\_all(v, xs) → {list}\n```\n\nReturns a list that results from `xs` by removing all items from `xs` that are identical (`===`) to `v`. Returns the original list if there is no occurrence. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "reverse",
      "title": "reverse(xs) → {list}",
      "description": "```source\nreverse(xs) → {list}\n```\n\nReturns list `xs` in reverse order. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`. The process is iterative, but consumes space `Theta(n)` because of the result list.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "set_head",
      "title": "set_head(p, x) → {undefined}",
      "description": "```source\nset\\_head(p, x) → {undefined}\n```\n\nchanges the pair `p` such that its head is `x`.",
      "meta": "func",
      "parameters": [
        "p",
        "x"
      ]
    },
    {
      "label": "set_tail",
      "title": "set_tail(p, x) → {undefined}",
      "description": "```source\nset\\_tail(p, x) → {undefined}\n```\n\nchanges the pair `p` such that its tail is `x`.",
      "meta": "func",
      "parameters": [
        "p",
        "x"
      ]
    },
    {
      "label": "stream",
      "title": "stream() → {stream}",
      "description": "```source\nstream() → {stream}\n```\n\nGiven `n` values, returns a stream of length `n`. The elements of the stream are the given values in the given order. Lazy? No: A complete list is generated, and then a stream using `list_to_stream` is generated from it.",
      "meta": "func",
      "parameters": [],
      "hasRestElement": true
    },
    {
      "label": "stream_append",
      "title": "stream_append(xs, ys) → {stream}",
      "description": "```source\nstream\\_append(xs, ys) → {stream}\n```\n\nReturns a stream that results from appending the stream `ys` to the stream `xs`. In the result, null at the end of the first argument stream is replaced by the second argument, regardless what the second argument consists of. Lazy? Yes: the result stream forces the actual append operation",
      "meta": "func",
      "parameters": [
        "xs",
        "ys"
      ]
    },
    {
      "label": "stream_filter",
      "title": "stream_filter(pred, xs) → {stream}",
      "description": "```source\nstream\\_filter(pred, xs) → {stream}\n```\n\nReturns a stream that contains only those elements of given stream `xs` for which the one-argument function `pred` returns `true`. Lazy? Yes: The result stream forces the construction of each next element. Of course, the construction of the next element needs to go down the stream until an element is found for which `pred` holds.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "stream_for_each",
      "title": "stream_for_each(f, xs) → {boolean}",
      "description": "```source\nstream\\_for\\_each(f, xs) → {boolean}\n```\n\nApplies unary function `f` to every element of the stream `xs`. Iterative process. `f` is applied element-by-element: `stream_for_each(f, stream(1, 2))` results in the calls `f(1)` and `f(2)`. Lazy? No: `stream_for_each` forces the exploration of the entire stream",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "stream_length",
      "title": "stream_length(xs) → {number}",
      "description": "```source\nstream\\_length(xs) → {number}\n```\n\nReturns the length of the stream `xs`. Iterative process. Lazy? No: The function needs to explore the whole stream",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "stream_map",
      "title": "stream_map(f, xs) → {stream}",
      "description": "```source\nstream\\_map(f, xs) → {stream}\n```\n\nReturns a stream that results from stream `xs` by element-wise application of unary function `f`. `f` is applied element-by-element: `stream_map(f, stream(1,2))` results in the same as `stream(f(1),f(2))`. Lazy? Yes: The argument stream is only explored as forced by the result stream.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "stream_member",
      "title": "stream_member(v, xs) → {stream}",
      "description": "```source\nstream\\_member(v, xs) → {stream}\n```\n\nReturns first postfix substream whose head is identical to `v` (using `===`); returns `null` if the element does not occur in the stream. Iterative process. Lazy? Sort-of: `stream_member` forces the stream only until the element is found.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "stream_ref",
      "title": "stream_ref(xs, n) → {value}",
      "description": "```source\nstream\\_ref(xs, n) → {value}\n```\n\nReturns the element of stream `xs` at position `n`, where the first element has index 0. Iterative process. Lazy? Sort-of: `stream_ref` only forces the computation of the first `n` elements, and leaves the rest of the stream untouched.",
      "meta": "func",
      "parameters": [
        "xs",
        "n"
      ]
    },
    {
      "label": "stream_remove",
      "title": "stream_remove(v, xs) → {stream}",
      "description": "```source\nstream\\_remove(v, xs) → {stream}\n```\n\nReturns a stream that results from `xs` by removing the first item from `xs` that is identical (`===`) to `v`. Returns the original stream if there is no occurrence. Lazy? Yes: the result stream forces the construction of each next element",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "stream_remove_all",
      "title": "stream_remove_all(v, xs) → {stream}",
      "description": "```source\nstream\\_remove\\_all(v, xs) → {stream}\n```\n\nReturns a stream that results from `xs` by removing all items from `xs` that are identical (`===`) to `v`. Returns the original stream if there is no occurrence. Recursive process. Lazy? Yes: the result stream forces the construction of each next element",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "stream_reverse",
      "title": "stream_reverse(xs) → {stream}",
      "description": "```source\nstream\\_reverse(xs) → {stream}\n```\n\nReturns stream `xs` in reverse order. Iterative process. The process is iterative, but consumes space `Omega(n)` because of the result stream. Lazy? No: `stream_reverse` forces the exploration of the entire stream",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "stream_tail",
      "title": "stream_tail(xs) → {Stream}",
      "description": "```source\nstream\\_tail(xs) → {Stream}\n```\n\nassumes that the tail (second component) of the pair {x} is a nullary function, and returns the result of applying that function. Throws an exception if the argument is not a pair, or if the tail is not a function. Laziness: Yes: {stream\\_tail} only forces the direct tail stream, but not the rest of the stream, i.e. not the tail of the tail, etc.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "stream_to_list",
      "title": "stream_to_list(xs) → {list}",
      "description": "```source\nstream\\_to\\_list(xs) → {list}\n```\n\nGiven stream `xs`, returns a list of same length with the same elements as `xs` in the same order. Laziness: No: `stream_to_list` needs to force the whole stream.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "stringify",
      "title": "stringify(v) → {string}",
      "description": "```source\nstringify(v) → {string}\n```\n\nreturns a string that represents the value `v`, using a notation that is is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects. See also [textbook example](https://sourceacademy.org/sicpjs/3.3.5).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "tail",
      "title": "tail(p) → {value}",
      "description": "```source\ntail(p) → {value}\n```\n\n\\*\\*primitive\\*\\*; returns tail (second component of given pair `p`; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "p"
      ]
    }
  ],
  [
    {
      "label": "Infinity",
      "title": "Infinity:number",
      "description": "```source\nInfinity:number\n```\n\nThe name `Infinity` refers to the special number value `Infinity`. See [ECMAScript Specification, Section 4.3.23](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-value-properties-of-the-global-object-infinity)",
      "meta": "const"
    },
    {
      "label": "math_E",
      "title": "math_E:number",
      "description": "```source\nmath\\_E:number\n```\n\nThe Number value for e, Euler's number, which is approximately 2.718281828459045.",
      "meta": "const"
    },
    {
      "label": "math_LN2",
      "title": "math_LN2:number",
      "description": "```source\nmath\\_LN2:number\n```\n\nThe Number value for the natural logarithm of 2, which is approximately 0.6931471805599453.",
      "meta": "const"
    },
    {
      "label": "math_LN10",
      "title": "math_LN10:number",
      "description": "```source\nmath\\_LN10:number\n```\n\nThe Number value for the natural logarithm of 10, which is approximately 2.302585092994046.",
      "meta": "const"
    },
    {
      "label": "math_LOG2E",
      "title": "math_LOG2E:number",
      "description": "```source\nmath\\_LOG2E:number\n```\n\nThe Number value for the base-2 logarithm of eℝ, the base of the natural logarithms; this value is approximately 1.4426950408889634.\n\nNOTE: The value of math\\_LOG2E is approximately the reciprocal of the value of math\\_LN2.",
      "meta": "const"
    },
    {
      "label": "math_LOG10E",
      "title": "math_LOG10E:number",
      "description": "```source\nmath\\_LOG10E:number\n```\n\nThe Number value for the base-10 logarithm of e, the base of the natural logarithms; this value is approximately 0.4342944819032518.\n\nNOTE: The value of math\\_LOG10E is approximately the reciprocal of the value of math\\_LN10.",
      "meta": "const"
    },
    {
      "label": "math_PI",
      "title": "math_PI:number",
      "description": "```source\nmath\\_PI:number\n```\n\nThe Number value for π, the ratio of the circumference of a circle to its diameter, which is approximately 3.1415926535897932.",
      "meta": "const"
    },
    {
      "label": "math_SQRT1_2",
      "title": "math_SQRT1_2:number",
      "description": "```source\nmath\\_SQRT1\\_2:number\n```\n\nThe Number value for the square root of 0.5, which is approximately 0.7071067811865476.\n\nNOTE: The value of math\\_SQRT1\\_2 is approximately the reciprocal of the value of math\\_SQRT2.",
      "meta": "const"
    },
    {
      "label": "math_SQRT2",
      "title": "math_SQRT2:number",
      "description": "```source\nmath\\_SQRT2:number\n```\n\nThe Number value for the square root of 2, which is approximately 1.4142135623730951.",
      "meta": "const"
    },
    {
      "label": "NaN",
      "title": "NaN:number",
      "description": "```source\nNaN:number\n```\n\nThe name `NaN` refers to the special number value `NaN` (\"not a number\"). Note that `NaN` is a number, as specified by `is_number`. See [ECMAScript Specification, Section 4.3.24](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-value-properties-of-the-global-object-nan)",
      "meta": "const"
    },
    {
      "label": "undefined",
      "title": "undefined:undefined",
      "description": "```source\nundefined:undefined\n```\n\nThe name `undefined` refers to the special value `undefined`. See also [textbook explanation in section 4.1.1](https://sourceacademy.org/sicpjs/4.1.1#h5).",
      "meta": "const"
    },
    {
      "label": "__access_export__",
      "title": "__access_export__(exports, lookup_name) → {value}",
      "description": "```source\n\\_\\_access\\_export\\_\\_(exports, lookup\\_name) → {value}\n```\n\nSearches for the specified name in the data structure of exported names. The data structure is a pair where the head element is the default export and the tail element is a list of pairs where each pair is a mapping from the exported name to the value being exported. If the lookup name is \"default\", the default export is returned instead of a named export. If the name does not exist, `undefined` is returned.",
      "meta": "func",
      "parameters": [
        "exports",
        "lookup_name"
      ]
    },
    {
      "label": "__access_named_export__",
      "title": "__access_named_export__(named_exports, lookup_name) → {value}",
      "description": "```source\n\\_\\_access\\_named\\_export\\_\\_(named\\_exports, lookup\\_name) → {value}\n```\n\nSearches for the specified name in the data structure of exported names. The data structure is a list of pairs where each pair is a mapping from the exported name to the value being exported. If the name does not exist, `undefined` is returned.",
      "meta": "func",
      "parameters": [
        "named_exports",
        "lookup_name"
      ]
    },
    {
      "label": "accumulate",
      "title": "accumulate(f, initial, xs) → {value}",
      "description": "```source\naccumulate(f, initial, xs) → {value}\n```\n\nApplies binary function `f` to the elements of `xs` from right-to-left order, first applying `f` to the last element and the value `initial`, resulting in `r`1, then to the second-last element and `r`1, resulting in `r`2, etc, and finally to the first element and `r`n-1, where `n` is the length of the list. Thus, `accumulate(f,zero,list(1,2,3))` results in `f(1, f(2, f(3, zero)))`. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(n)` (apart from `f`), where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "(x, y) => ",
        "initial",
        "xs"
      ]
    },
    {
      "label": "append",
      "title": "append(xs, ys) → {list}",
      "description": "```source\nappend(xs, ys) → {list}\n```\n\nReturns a list that results from appending the list `ys` to the list `xs`. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`. In the result, null at the end of the first argument list is replaced by the second argument, regardless what the second argument consists of.",
      "meta": "func",
      "parameters": [
        "xs",
        "ys"
      ]
    },
    {
      "label": "apply_in_underlying_javascript",
      "title": "apply_in_underlying_javascript(f, xs) → {whatever}",
      "description": "```source\napply\\_in\\_underlying\\_javascript(f, xs) → {whatever}\n```\n\ncalls the function `f` with arguments given in list `xs`. For example:\n\n    function times(x, y) {\n    return x * y;\n    }\n    apply_in_underlying_javascript(times, list(2, 3)); // returns 6",
      "meta": "func",
      "parameters": [
        "f",
        "xs"
      ]
    },
    {
      "label": "arity",
      "title": "arity(f) → {number}",
      "description": "```source\narity(f) → {number}\n```\n\nReturns the number of parameters the given function `f` expects, excluding the rest parameter.",
      "meta": "func",
      "parameters": [
        "f"
      ]
    },
    {
      "label": "array_length",
      "title": "array_length(x) → {number}",
      "description": "```source\narray\\_length(x) → {number}\n```\n\n\\*\\*primitive\\*\\*; returns the current length of array `x`, which is 1 plus the highest index that has been used so far in an array assignment on `x`. Here literal array expressions are counted too: The array `[10, 20, 30]` has a length of 3. Time: `Θ(1)`, space: `Θ(1)`",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "build_list",
      "title": "build_list(f, n) → {list}",
      "description": "```source\nbuild\\_list(f, n) → {list}\n```\n\nMakes a list with `n` elements by applying the unary function `f` to the numbers 0 to `n - 1`, assumed to be a nonnegative integer. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(n)` (apart from `f`).",
      "meta": "func",
      "parameters": [
        "x => ",
        "n"
      ]
    },
    {
      "label": "build_stream",
      "title": "build_stream(f, n) → {stream}",
      "description": "```source\nbuild\\_stream(f, n) → {stream}\n```\n\nMakes a stream with `n` elements by applying the unary function `f` to the numbers 0 to `n - 1`, assumed to be a nonnegative integer. Lazy? Yes: The result stream forces the application of `f` for the next element",
      "meta": "func",
      "parameters": [
        "x => ",
        "n"
      ]
    },
    {
      "label": "char_at",
      "title": "char_at(s, i) → {string}",
      "description": "```source\nchar\\_at(s, i) → {string}\n```\n\nTakes a string `s` as first argument and a nonnegative integer `i` as second argument. If `i` is less than the length of `s`, this function returns a one-character string that contains the character of `s` at position `i`, counting from 0. If `i` is larger than or equal to the length of `s`, this function returns `undefined`.",
      "meta": "func",
      "parameters": [
        "s",
        "i"
      ]
    },
    {
      "label": "display",
      "title": "display(v, s) → {value}",
      "description": "```source\ndisplay(v, s) → {value}\n```\n\nOptional second argument. If present, displays the given string `s`, followed by a space character, followed by the value `v` in the console. If second argument not present, just displays the value `v` in the console. The notation used for the display of values is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects.",
      "meta": "func",
      "parameters": [
        "v",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "display_list",
      "title": "display_list(xs, s) → {value}",
      "description": "```source\ndisplay\\_list(xs, s) → {value}\n```\n\nOptional second argument. Similar to `display`, but formats well-formed lists nicely if detected; time, space: `Theta(n)`, where `n` is the total number of data structures such as pairs in `x`.",
      "meta": "func",
      "parameters": [
        "xs",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "draw_data",
      "title": "draw_data() → {value}",
      "description": "```source\ndraw\\_data() → {value}\n```\n\nvisualizes the arguments in a separate drawing area in the Source Academy using box-and-pointer diagrams; time, space: `Theta(n)`, where `n` is the total number of data structures such as pairs in the arguments.",
      "meta": "func",
      "parameters": [],
      "hasRestElement": true
    },
    {
      "label": "enum_list",
      "title": "enum_list(start, end) → {list}",
      "description": "```source\nenum\\_list(start, end) → {list}\n```\n\nReturns a list that enumerates numbers starting from `start` using a step size of 1, until the number exceeds (`>`) `end`. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is `end - start`.",
      "meta": "func",
      "parameters": [
        "start",
        "end"
      ]
    },
    {
      "label": "enum_stream",
      "title": "enum_stream(start, end) → {stream}",
      "description": "```source\nenum\\_stream(start, end) → {stream}\n```\n\nReturns a stream that enumerates numbers starting from `start` using a step size of 1, until the number exceeds (`>`) `end`. Lazy? Yes: The result stream forces the construction of each next element",
      "meta": "func",
      "parameters": [
        "start",
        "end"
      ]
    },
    {
      "label": "equal",
      "title": "equal(x, y) → {boolean}",
      "description": "```source\nequal(x, y) → {boolean}\n```\n\nReturns `true` if both have the same structure with respect to `pair`, and identical values at corresponding leave positions (places that are not themselves pairs), and `false` otherwise. For the \"identical\", the values need to have the same type, otherwise the result is `false`. If corresponding leaves are boolean values, these values need to be the same. If both are `undefined` or both are `null`, the result is `true`. Otherwise they are compared with `===` (using the definition of `===` in the respective Source language in use). Time, space: `Theta(n)`, where `n` is the total number of data structures such as pairs in `x` and `y`.",
      "meta": "func",
      "parameters": [
        "x",
        "y"
      ]
    },
    {
      "label": "error",
      "title": "error(v, s)",
      "description": "```source\nerror(v, s)\n```\n\nOptional second argument. If present, displays the given string `s`, followed by a space character, followed by the value `v` in the console with error flag. If second argument not present, just displays the value `v` in the console with error flag. The evaluation of any call of `error` aborts the running program immediately. The notation used for the display of values is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects.",
      "meta": "func",
      "parameters": [
        "v",
        "s"
      ],
      "optional_params": [
        "s"
      ]
    },
    {
      "label": "eval_stream",
      "title": "eval_stream(s, n) → {list}",
      "description": "```source\neval\\_stream(s, n) → {list}\n```\n\nConstructs the list of the first `n` elements of a given stream `s` Lazy? Sort-of: `eval_stream` only forces the computation of the first `n` elements, and leaves the rest of the stream untouched.",
      "meta": "func",
      "parameters": [
        "s",
        "n"
      ]
    },
    {
      "label": "filter",
      "title": "filter(pred, xs) → {list}",
      "description": "```source\nfilter(pred, xs) → {list}\n```\n\nReturns a list that contains only those elements for which the one-argument function `pred` returns `true`. Iterative process; time: `Theta(n)` (apart from `pred`), space: `Theta(n)` (apart from `pred`), where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "for_each",
      "title": "for_each(f, xs) → {boolean}",
      "description": "```source\nfor\\_each(f, xs) → {boolean}\n```\n\nApplies unary function `f` to every element of the list `xs`. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(1)` (apart from `f`), where `n` is the length of `xs`. `f` is applied element-by-element: `for_each(fun, list(1, 2))` results in the calls `fun(1)` and `fun(2)`.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "get_time",
      "title": "get_time() → {number}",
      "description": "```source\nget\\_time() → {number}\n```\n\nReturns number of milliseconds elapsed since January 1, 1970 00:00:00 UTC. See also [textbook example](https://sourceacademy.org/sicpjs/1.2.6#ex-1.21).",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "head",
      "title": "head(p) → {value}",
      "description": "```source\nhead(p) → {value}\n```\n\n\\*\\*primitive\\*\\*; returns head (first component) of given pair `p`; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "p"
      ]
    },
    {
      "label": "integers_from",
      "title": "integers_from(start) → {stream}",
      "description": "```source\nintegers\\_from(start) → {stream}\n```\n\nReturns infinite stream if integers starting at given number `n` using a step size of 1. Lazy? Yes: The result stream forces the construction of each next element",
      "meta": "func",
      "parameters": [
        "start"
      ]
    },
    {
      "label": "is_array",
      "title": "is_array(x) → {boolean}",
      "description": "```source\nis\\_array(x) → {boolean}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `x` is an array, and `false` if it is not. Time: `Θ(1)`, space: `Θ(1)`",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "is_boolean",
      "title": "is_boolean(v) → {boolean}",
      "description": "```source\nis\\_boolean(v) → {boolean}\n```\n\nchecks whether a given value is a boolean",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_function",
      "title": "is_function(v) → {boolean}",
      "description": "```source\nis\\_function(v) → {boolean}\n```\n\nchecks whether a given value is a function",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_list",
      "title": "is_list(xs) → {xs}",
      "description": "```source\nis\\_list(xs) → {xs}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `xs` is a list as defined in the textbook, and `false` otherwise. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of the chain of `tail` operations that can be applied to `xs`. `is_list` recurses down the list and checks that it ends with the empty list null",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "is_null",
      "title": "is_null(x) → {boolean}",
      "description": "```source\nis\\_null(x) → {boolean}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `x` is the empty list `null`, and `false` otherwise; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "is_number",
      "title": "is_number(v) → {boolean}",
      "description": "```source\nis\\_number(v) → {boolean}\n```\n\nchecks whether a given value is a number. See also [textbook example](https://sourceacademy.org/sicpjs/2.3.2).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_pair",
      "title": "is_pair(x) → {boolean}",
      "description": "```source\nis\\_pair(x) → {boolean}\n```\n\n\\*\\*primitive\\*\\*; returns `true` if `x` is a pair and false otherwise; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "is_stream",
      "title": "is_stream(xs) → {boolean}",
      "description": "```source\nis\\_stream(xs) → {boolean}\n```\n\nReturns `true` if `xs` is a stream as defined in the textbook, and `false` otherwise. Iterative process. Recurses down the stream and checks that it ends with the empty stream null. Laziness: No: `is_stream` needs to force the given stream.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "is_string",
      "title": "is_string(v) → {boolean}",
      "description": "```source\nis\\_string(v) → {boolean}\n```\n\nchecks whether a given value is a string. See also [textbook example](https://sourceacademy.org/sicpjs/2.3.2).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "is_undefined",
      "title": "is_undefined(v) → {boolean}",
      "description": "```source\nis\\_undefined(v) → {boolean}\n```\n\nchecks whether a given value is the special value `undefined`",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "length",
      "title": "length(xs) → {number}",
      "description": "```source\nlength(xs) → {number}\n```\n\nReturns the length of the list `xs`. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "list",
      "title": "list() → {list}",
      "description": "```source\nlist() → {list}\n```\n\n\\*\\*primitive\\*\\*; given `n` values, returns a list of length `n`. The elements of the list are the given values in the given order; time: `Theta(n)Theta(n)`.",
      "meta": "func",
      "parameters": [],
      "hasRestElement": true
    },
    {
      "label": "list_ref",
      "title": "list_ref(xs, n) → {value}",
      "description": "```source\nlist\\_ref(xs, n) → {value}\n```\n\nReturns the element of list `xs` at position `n`, where the first element has index 0. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "xs",
        "n"
      ]
    },
    {
      "label": "list_to_stream",
      "title": "list_to_stream(xs) → {stream}",
      "description": "```source\nlist\\_to\\_stream(xs) → {stream}\n```\n\nGiven list `xs`, returns a stream of same length with the same elements as `xs` in the same order. Laziness: Yes: `list_to_stream` goes down the list only when forced.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "list_to_string",
      "title": "list_to_string(xs) → {string}",
      "description": "```source\nlist\\_to\\_string(xs) → {string}\n```\n\nReturns a string that represents list `xs` using the text-based box-and-pointer notation `[...]`. Iterative process; time: `Theta(n)` where `n` is the size of the list, space: `Theta(m)` where `m` is the length of the string. The process is iterative, but consumes space `O(m)` because of the result string.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "map",
      "title": "map(f, xs) → {list}",
      "description": "```source\nmap(f, xs) → {list}\n```\n\nReturns a list that results from list `xs` by element-wise application of unary function `f`. Iterative process; time: `Theta(n)` (apart from `f`), space: `Theta(n)` (apart from `f`), where `n` is the length of `xs`. `f` is applied element-by-element: `map(f, list(1, 2))` results in `list(f(1), f(2))`.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "math_abs",
      "title": "math_abs(x) → {number}",
      "description": "```source\nmath\\_abs(x) → {number}\n```\n\ncomputes the absolute value of x; the result has the same magnitude as `x` but has positive sign.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_acos",
      "title": "math_acos(x) → {number}",
      "description": "```source\nmath\\_acos(x) → {number}\n```\n\ncomputes the arc cosine of `x`. The result is expressed in radians and ranges from +0 to +π.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_acosh",
      "title": "math_acosh(x) → {number}",
      "description": "```source\nmath\\_acosh(x) → {number}\n```\n\ncomputes the inverse hyperbolic cosine of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_asin",
      "title": "math_asin(x) → {number}",
      "description": "```source\nmath\\_asin(x) → {number}\n```\n\ncomputes the arc sine of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_asinh",
      "title": "math_asinh(x) → {number}",
      "description": "```source\nmath\\_asinh(x) → {number}\n```\n\ncomputes the inverse hyperbolic sine of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_atan",
      "title": "math_atan(x) → {number}",
      "description": "```source\nmath\\_atan(x) → {number}\n```\n\ncomputes the arc tangent of `x`. The result is expressed in radians and ranges from -π / 2 to +π / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_atan2",
      "title": "math_atan2(y, x) → {number}",
      "description": "```source\nmath\\_atan2(y, x) → {number}\n```\n\ncomputes the arc tangent of the quotient `y` / `x` of the arguments `y` and `x`, where the signs of `y` and `x` are used to determine the quadrant of the result. Note that it is intentional and traditional for the two-argument arc tangent function that the argument named `y` be first and the argument named `x` be second. The result is expressed in radians and ranges from -π to +π.",
      "meta": "func",
      "parameters": [
        "y",
        "x"
      ]
    },
    {
      "label": "math_atanh",
      "title": "math_atanh(x) → {number}",
      "description": "```source\nmath\\_atanh(x) → {number}\n```\n\ncomputes the inverse hyperbolic tangent of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_cbrt",
      "title": "math_cbrt(x) → {number}",
      "description": "```source\nmath\\_cbrt(x) → {number}\n```\n\ncomputes the cube root of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_ceil",
      "title": "math_ceil(x) → {number}",
      "description": "```source\nmath\\_ceil(x) → {number}\n```\n\ncomputes the smallest (closest to -∞) Number value that is not less than `x` and is an integer. If `x` is already an integer, the result is `x`. The value of math\\_ceil(x) is the same as the value of -math\\_floor(-x).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_clz32",
      "title": "math_clz32(n) → {number}",
      "description": "```source\nmath\\_clz32(n) → {number}\n```\n\nWhen math\\_clz32 is called with one argument `x`, the following steps are taken: Let n be ToUint32(x). Let p be the number of leading zero bits in the 32-bit binary representation of n. Return p.\n\nNOTE:  \nIf n is 0, p will be 32. If the most significant bit of the 32-bit binary encoding of n is 1, p will be 0.",
      "meta": "func",
      "parameters": [
        "n"
      ]
    },
    {
      "label": "math_cos",
      "title": "math_cos(x) → {number}",
      "description": "```source\nmath\\_cos(x) → {number}\n```\n\nComputes the cosine of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_cosh",
      "title": "math_cosh(x) → {number}",
      "description": "```source\nmath\\_cosh(x) → {number}\n```\n\ncomputes the hyperbolic cosine of `x`.\n\nNOTE: The value of cosh(x) is the same as (exp(x) + exp(-x)) / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_exp",
      "title": "math_exp(x) → {number}",
      "description": "```source\nmath\\_exp(x) → {number}\n```\n\ncomputes the exponential function of `x` (e raised to the power of `x`, where e is the base of the natural logarithms).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_expm1",
      "title": "math_expm1(x) → {number}",
      "description": "```source\nmath\\_expm1(x) → {number}\n```\n\ncomputes subtracting 1 from the exponential function of `x` (e raised to the power of `x`, where e is the base of the natural logarithms). The result is computed in a way that is accurate even when the value of `x` is close to 0.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_floor",
      "title": "math_floor(x) → {number}",
      "description": "```source\nmath\\_floor(x) → {number}\n```\n\ncomputes the greatest (closest to +∞) Number value that is not greater than `x` and is an integer.  \nIf `x` is already an integer, the result is `x`.\n\nNOTE: The value of math\\_floor(x) is the same as the value of -math\\_ceil(-x).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_fround",
      "title": "math_fround(x) → {number}",
      "description": "```source\nmath\\_fround(x) → {number}\n```\n\nWhen math\\_fround is called with argument `x`, the following steps are taken:\n\n1.  If `x` is NaN, return NaN.\n2.  If `x` is one of +0, -0, +∞, -∞, return `x`.\n3.  Let x32 be the result of converting `x` to a value in IEEE 754-2008 binary32 format using roundTiesToEven mode.\n4.  Let x64 be the result of converting x32 to a value in IEEE 754-2008 binary64 format.\n5.  Return the ECMAScript Number value corresponding to x64.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_hypot",
      "title": "math_hypot() → {number}",
      "description": "```source\nmath\\_hypot() → {number}\n```\n\ncomputes the square root of the sum of squares of its arguments.  \nIf no arguments are passed, the result is +0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_imul",
      "title": "math_imul(x, x) → {number}",
      "description": "```source\nmath\\_imul(x, x) → {number}\n```\n\nWhen math\\_imul is called with arguments `x` and `y`, the following steps are taken:\n\n1.  Let a be ToUint32(x).\n2.  Let b be ToUint32(y).\n3.  Let product be (a × b) modulo 232.\n4.  If product ≥ 231, return product - 232; otherwise return product.",
      "meta": "func",
      "parameters": [
        "x",
        "x"
      ]
    },
    {
      "label": "math_log",
      "title": "math_log(x) → {number}",
      "description": "```source\nmath\\_log(x) → {number}\n```\n\nComputes the natural logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log1p",
      "title": "math_log1p(x) → {number}",
      "description": "```source\nmath\\_log1p(x) → {number}\n```\n\ncomputes the natural logarithm of 1 + `x`. The result is computed in a way that is accurate even when the value of `x` is close to zero.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log2",
      "title": "math_log2(x) → {number}",
      "description": "```source\nmath\\_log2(x) → {number}\n```\n\ncomputes the base 2 logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_log10",
      "title": "math_log10(x) → {number}",
      "description": "```source\nmath\\_log10(x) → {number}\n```\n\ncomputes the base 10 logarithm of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_max",
      "title": "math_max() → {number}",
      "description": "```source\nmath\\_max() → {number}\n```\n\nGiven zero or more numbers, returns the largest of them.  \nIf no arguments are given, the result is -∞.  \nIf any value is NaN, the result is NaN. The comparison of values to determine the largest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_min",
      "title": "math_min() → {number}",
      "description": "```source\nmath\\_min() → {number}\n```\n\nGiven zero or more arguments, returns the smallest of them.  \nIf no arguments are given, the result is +∞.  \nIf any value is NaN, the result is NaN. The comparison of values to determine the smallest value is done using the Abstract Relational Comparison algorithm except that +0 is considered to be larger than -0.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_pow",
      "title": "math_pow(base, exponent) → {number}",
      "description": "```source\nmath\\_pow(base, exponent) → {number}\n```\n\nComputes the result of raising base to the power of exponent.",
      "meta": "func",
      "parameters": [
        "base",
        "exponent"
      ]
    },
    {
      "label": "math_random",
      "title": "math_random() → {number}",
      "description": "```source\nmath\\_random() → {number}\n```\n\nReturns a number value with positive sign, greater than or equal to 0 but less than 1, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. This function takes no arguments. Each math\\_random function created for distinct realms must produce a distinct sequence of values from successive calls.",
      "meta": "func",
      "parameters": []
    },
    {
      "label": "math_round",
      "title": "math_round(x) → {number}",
      "description": "```source\nmath\\_round(x) → {number}\n```\n\nReturns the number value that is closest to `x` and is an integer.  \nIf two integers are equally close to `x`, then the result is the Number value that is closer to +∞. If `x` is already an integer, the result is `x`. NOTE 1: math\\_round(3.5) returns 4, but math\\_round(-3.5) returns -3.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sign",
      "title": "math_sign(x) → {number}",
      "description": "```source\nmath\\_sign(x) → {number}\n```\n\nComputes the sign of `x`, indicating whether `x` is positive, negative, or zero.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sin",
      "title": "math_sin(x) → {number}",
      "description": "```source\nmath\\_sin(x) → {number}\n```\n\nComputes the sine of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sinh",
      "title": "math_sinh(x) → {number}",
      "description": "```source\nmath\\_sinh(x) → {number}\n```\n\nComputes the hyperbolic sine of `x`.\n\nNOTE: The value of sinh(x) is the same as (exp(x) - exp(-x)) / 2.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_sqrt",
      "title": "math_sqrt(x) → {number}",
      "description": "```source\nmath\\_sqrt(x) → {number}\n```\n\nComputes the square root of `x`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_tan",
      "title": "math_tan(x) → {number}",
      "description": "```source\nmath\\_tan(x) → {number}\n```\n\nComputes the tangent of `x`. The argument is expressed in radians.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_tanh",
      "title": "math_tanh(x) → {number}",
      "description": "```source\nmath\\_tanh(x) → {number}\n```\n\nComputes the hyperbolic tangent of `x`.\n\nNOTE: The value of `math_tanh(x)` is the same as `(exp(x) - exp(-x))/(exp(x) + exp(-x))`.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "math_trunc",
      "title": "math_trunc(x) → {number}",
      "description": "```source\nmath\\_trunc(x) → {number}\n```\n\nComputes the integral part of the number `x`, removing any fractional digits.",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "member",
      "title": "member(v, xs) → {list}",
      "description": "```source\nmember(v, xs) → {list}\n```\n\nReturns first postfix sublist whose head is identical to `v` (using `===`); returns `null` if the element does not occur in the list. Iterative process; time: `Theta(n)`, space: `Theta(1)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "pair",
      "title": "pair(x, y) → {pair}",
      "description": "```source\npair(x, y) → {pair}\n```\n\n\\*\\*primitive\\*\\*; makes a pair whose head (first component) is `x` and whose tail (second component) is `y`; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "x",
        "y"
      ]
    },
    {
      "label": "parse",
      "title": "parse(x) → {value}",
      "description": "```source\nparse(x) → {value}\n```\n\nreturns the parse tree that results from parsing the string `str` as a Source program. The format of the parse tree is described in chapter 4 of the textbook in [Structure and Interpretation of Computer Programs, JavaScript Adaptation](https://sourceacademy.org/sicpjs/) (SICP).",
      "meta": "func",
      "parameters": [
        "x"
      ]
    },
    {
      "label": "parse_int",
      "title": "parse_int(s, i) → {number}",
      "description": "```source\nparse\\_int(s, i) → {number}\n```\n\nInterprets a given string `s` as an integer, using the positive integer `i` as radix, and returns the respective value.  \nExamples: `parse_int(\"909\", 10)` returns the number `909`, and `parse_int(\"-1111\", 2)` returns the number `-15`.  \nSee [ECMAScript Specification, Section 18.2.5](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-parseint-string-radix) for details.",
      "meta": "func",
      "parameters": [
        "s",
        "i"
      ]
    },
    {
      "label": "prompt",
      "title": "prompt(s) → {string}",
      "description": "```source\nprompt(s) → {string}\n```\n\nPops up a window that displays the string `s`, provides an input line for the user to enter a text, a `Cancel` button and an `OK` button. The call of `prompt` suspends execution of the program until one of the two buttons is pressed. If the `OK` button is pressed, `prompt` returns the entered text as a string. If the `Cancel` button is pressed, `prompt` returns a non-string value.",
      "meta": "func",
      "parameters": [
        "s"
      ]
    },
    {
      "label": "remove",
      "title": "remove(v, xs) → {list}",
      "description": "```source\nremove(v, xs) → {list}\n```\n\nReturns a list that results from `xs` by removing the first item from `xs` that is identical (`===`) to `v`. Returns the original list if there is no occurrence. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "remove_all",
      "title": "remove_all(v, xs) → {list}",
      "description": "```source\nremove\\_all(v, xs) → {list}\n```\n\nReturns a list that results from `xs` by removing all items from `xs` that are identical (`===`) to `v`. Returns the original list if there is no occurrence. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "reverse",
      "title": "reverse(xs) → {list}",
      "description": "```source\nreverse(xs) → {list}\n```\n\nReturns list `xs` in reverse order. Iterative process; time: `Theta(n)`, space: `Theta(n)`, where `n` is the length of `xs`. The process is iterative, but consumes space `Theta(n)` because of the result list.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "set_head",
      "title": "set_head(p, x) → {undefined}",
      "description": "```source\nset\\_head(p, x) → {undefined}\n```\n\nchanges the pair `p` such that its head is `x`.",
      "meta": "func",
      "parameters": [
        "p",
        "x"
      ]
    },
    {
      "label": "set_tail",
      "title": "set_tail(p, x) → {undefined}",
      "description": "```source\nset\\_tail(p, x) → {undefined}\n```\n\nchanges the pair `p` such that its tail is `x`.",
      "meta": "func",
      "parameters": [
        "p",
        "x"
      ]
    },
    {
      "label": "stream",
      "title": "stream() → {stream}",
      "description": "```source\nstream() → {stream}\n```\n\nGiven `n` values, returns a stream of length `n`. The elements of the stream are the given values in the given order. Lazy? No: A complete list is generated, and then a stream using `list_to_stream` is generated from it.",
      "meta": "func",
      "parameters": [],
      "hasRestElement": true
    },
    {
      "label": "stream_append",
      "title": "stream_append(xs, ys) → {stream}",
      "description": "```source\nstream\\_append(xs, ys) → {stream}\n```\n\nReturns a stream that results from appending the stream `ys` to the stream `xs`. In the result, null at the end of the first argument stream is replaced by the second argument, regardless what the second argument consists of. Lazy? Yes: the result stream forces the actual append operation",
      "meta": "func",
      "parameters": [
        "xs",
        "ys"
      ]
    },
    {
      "label": "stream_filter",
      "title": "stream_filter(pred, xs) → {stream}",
      "description": "```source\nstream\\_filter(pred, xs) → {stream}\n```\n\nReturns a stream that contains only those elements of given stream `xs` for which the one-argument function `pred` returns `true`. Lazy? Yes: The result stream forces the construction of each next element. Of course, the construction of the next element needs to go down the stream until an element is found for which `pred` holds.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "stream_for_each",
      "title": "stream_for_each(f, xs) → {boolean}",
      "description": "```source\nstream\\_for\\_each(f, xs) → {boolean}\n```\n\nApplies unary function `f` to every element of the stream `xs`. Iterative process. `f` is applied element-by-element: `stream_for_each(f, stream(1, 2))` results in the calls `f(1)` and `f(2)`. Lazy? No: `stream_for_each` forces the exploration of the entire stream",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "stream_length",
      "title": "stream_length(xs) → {number}",
      "description": "```source\nstream\\_length(xs) → {number}\n```\n\nReturns the length of the stream `xs`. Iterative process. Lazy? No: The function needs to explore the whole stream",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "stream_map",
      "title": "stream_map(f, xs) → {stream}",
      "description": "```source\nstream\\_map(f, xs) → {stream}\n```\n\nReturns a stream that results from stream `xs` by element-wise application of unary function `f`. `f` is applied element-by-element: `stream_map(f, stream(1,2))` results in the same as `stream(f(1),f(2))`. Lazy? Yes: The argument stream is only explored as forced by the result stream.",
      "meta": "func",
      "parameters": [
        "x => ",
        "xs"
      ]
    },
    {
      "label": "stream_member",
      "title": "stream_member(v, xs) → {stream}",
      "description": "```source\nstream\\_member(v, xs) → {stream}\n```\n\nReturns first postfix substream whose head is identical to `v` (using `===`); returns `null` if the element does not occur in the stream. Iterative process. Lazy? Sort-of: `stream_member` forces the stream only until the element is found.",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "stream_ref",
      "title": "stream_ref(xs, n) → {value}",
      "description": "```source\nstream\\_ref(xs, n) → {value}\n```\n\nReturns the element of stream `xs` at position `n`, where the first element has index 0. Iterative process. Lazy? Sort-of: `stream_ref` only forces the computation of the first `n` elements, and leaves the rest of the stream untouched.",
      "meta": "func",
      "parameters": [
        "xs",
        "n"
      ]
    },
    {
      "label": "stream_remove",
      "title": "stream_remove(v, xs) → {stream}",
      "description": "```source\nstream\\_remove(v, xs) → {stream}\n```\n\nReturns a stream that results from `xs` by removing the first item from `xs` that is identical (`===`) to `v`. Returns the original stream if there is no occurrence. Lazy? Yes: the result stream forces the construction of each next element",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "stream_remove_all",
      "title": "stream_remove_all(v, xs) → {stream}",
      "description": "```source\nstream\\_remove\\_all(v, xs) → {stream}\n```\n\nReturns a stream that results from `xs` by removing all items from `xs` that are identical (`===`) to `v`. Returns the original stream if there is no occurrence. Recursive process. Lazy? Yes: the result stream forces the construction of each next element",
      "meta": "func",
      "parameters": [
        "v",
        "xs"
      ]
    },
    {
      "label": "stream_reverse",
      "title": "stream_reverse(xs) → {stream}",
      "description": "```source\nstream\\_reverse(xs) → {stream}\n```\n\nReturns stream `xs` in reverse order. Iterative process. The process is iterative, but consumes space `Omega(n)` because of the result stream. Lazy? No: `stream_reverse` forces the exploration of the entire stream",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "stream_tail",
      "title": "stream_tail(xs) → {Stream}",
      "description": "```source\nstream\\_tail(xs) → {Stream}\n```\n\nassumes that the tail (second component) of the pair {x} is a nullary function, and returns the result of applying that function. Throws an exception if the argument is not a pair, or if the tail is not a function. Laziness: Yes: {stream\\_tail} only forces the direct tail stream, but not the rest of the stream, i.e. not the tail of the tail, etc.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "stream_to_list",
      "title": "stream_to_list(xs) → {list}",
      "description": "```source\nstream\\_to\\_list(xs) → {list}\n```\n\nGiven stream `xs`, returns a list of same length with the same elements as `xs` in the same order. Laziness: No: `stream_to_list` needs to force the whole stream.",
      "meta": "func",
      "parameters": [
        "xs"
      ]
    },
    {
      "label": "stringify",
      "title": "stringify(v) → {string}",
      "description": "```source\nstringify(v) → {string}\n```\n\nreturns a string that represents the value `v`, using a notation that is is consistent with [JSON](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), but also displays `undefined`, `NaN`, `Infinity`, and function objects. See also [textbook example](https://sourceacademy.org/sicpjs/3.3.5).",
      "meta": "func",
      "parameters": [
        "v"
      ]
    },
    {
      "label": "tail",
      "title": "tail(p) → {value}",
      "description": "```source\ntail(p) → {value}\n```\n\n\\*\\*primitive\\*\\*; returns tail (second component of given pair `p`; time: `Theta(1)Theta(1)`.",
      "meta": "func",
      "parameters": [
        "p"
      ]
    },
    {
      "label": "tokenize",
      "title": "tokenize(x) → {list}",
      "description": "```source\ntokenize(x) → {list}\n```\n\nreturns the list of tokens that results from lexing the string `str`",
      "meta": "func",
      "parameters": [
        "x"
      ]
    }
  ]
]